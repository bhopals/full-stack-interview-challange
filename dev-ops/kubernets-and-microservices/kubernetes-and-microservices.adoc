
=== Microservices 
Think of Microservices as a variant of service-oriented architecture that structures the entire
application as a collection of loosely coupled services.

Typically, microservices are broken up with the intent to solve a specific business need or
enable a business capability. 

==== Benefits 
 - freedom to create, manage, and deploy the individual components without compromising the 
   integrity of the entire application.
 - Enables fault tolerance and dfault isolation
 
 - language independence
 - use the right language at the hand 
 - Not pigeonhold to a single language just because the rest of the application uses it.
 - avoid bottleneck of scaling
 - Can be deployed independently
 - Risk of rolling the change back is easy

==== Continuous Delivery Deployment Types 
 Blue Green deployment or Red Black Deployment  - Switch between servers and ensure at least one server is alive at all time 
 A/B Deployment - Routing percentage of traffic on each while deploying   
 Rollback deployment - slowly starting from 1-2 servers instead of going for all simultaneous deployment to ensure the successfully deployment  
 Canary Deployment - release particular feature for certain set of users (Based on region or first name or age range)
 Minimum In-Service deployment - make a policy that minimum numbers of server stay alive while deployment is in progress.
 REFERENCE : https://caylent.com/docker-continuous-delivery-deployment-types/

Building microservices forces you to think about an applications in a more modular way.

For Greenfield opportunities there is a initial learning curve if we use microservice architecture and 
which would pay greater advantage on a long term.

==== The Twelve factor App
Applicable for all cloud and container application

I. Codebase
    One codebase tracked in revision control, many deploys
    GIT,DOCKER

II. Dependencies
    Explicitly declare and isolate dependencies
    MAVEN,NPM,GRADLE
    In kubernetes create a POD that can have all your dependencies. Commonly seen in kubernetes world - SideCar Pattern
III. Config
    Store config in the environment not part of codebase 
   
    Small footprint(small organisations ): Different namespaces with different credentials dev, staging and production
    Large footprint(larger organisations): Unique kubernetes installation for dev, stage, and production

    Applicaton config for kubernetes is ConfigMap and Secrets 
IV. Backing services
    Treat backing services as attached resources
    MYSQL, SMTP EMAIL

V. Build, release, run
    Strictly separate build and run stages
    JENKINS

VI. Processes
    Execute the app as one or more stateless processes
    Sticky session needs to be revisited and re-implemented

VII. Port binding
    Export services via port binding

VIII. Concurrency
    Scale out via the process model

IX. Disposability
    Maximize robustness with fast startup and graceful shutdown
    Quick Application startup and shutdown 

X. Dev/prod parity
    Keep development, staging, and production as similar as possible

XI. Logs
    Treat logs as event streams
    In kubernetes, common to use a log router (Beats/Fluentd) to save the logs to a service (ElasticSearch/Splunk)

XII. Admin processes
    Run admin/management tasks as one-off processes


All 12 Rules are basically categorised in 3 parts.
    - Microservices Building Block 
        - Codebase 
        - Dependencies 
        - Admin Processes
        - Dev/Staging/Production Parity 

    - Deployment Patterns 
        - Application Configurations 
        - Build, release, and run 
        - Processes
        - Port Binding 

    - Runtime Pattersn 
        - Backing around services 
        - Features and Concurrency 
        - Disposability
        - Log Management 

REFERENCE : https://12factor.net/
REFERENCE : https://martinfowler.com/microservices/

==== Microservices Deployment to kubernetes 

===== Deploying our application to Kubernetes

We're ready to deploy our application to Kubernetes, but let's take a look at our assets.

====== Goals:
1. View our sample application and containers
2. Take a look at our deployment file 
3. Take a look at our alternate deployment file
4. Deploy our application into kubernetes and verify we can see our API's working.

======= Goal 1
View the sample application here: 

======= Goal 2
To view the deployment file, take a look at wishlist-deployment.yaml

======= Goal 3
To see another way to run the microservices, take a look at wishlist-deployment-alernate.yaml

======= Goal 4
To run the microservice described in goal #1, from the current directory, run:

`kubectl create -f wishlist-deployment.yaml`

To verify that the deployment is online:
`kubectl get deployments`

To verify that the replica sets are running:
`kubectl get rs`

To verify that the pods are running:
`kubectl get pods`

To see the services:
`kubectl get services`

To interact with your API's in the minikube environment:
`minikube service wishlist-service`


# Wishlist deployment yaml
    kind: Deployment
    apiVersion: apps/v1
    metadata:
    name: wishlist-deployment
    labels:
        app: wishlist
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: wishlist
    template:
        metadata:
        labels:
            app: wishlist
        spec:
        containers:
        - name: wishlist #1st container
            image: karthequian/wishlist:1.0 #Dockerhub image
            ports:
            - containerPort: 8080 #Exposes the port 8080 of the container
            env:
            - name: PORT #Env variable key passed to container that is read by app
            value: "8080" # Value of the env port.
        - name: catalog #2nd container
            image: karthequian/wishlist-catalog:1.0
            ports:
            - containerPort: 8081
            env:
            - name: PORT
            value: "8081"
        - name: auth #3rd container
            image: karthequian/wishlist-auth:1.0
            ports:
            - containerPort: 8082
            env:
            - name: PORT
            value: "8082"
    ---
    kind: Service
    apiVersion: v1
    metadata:
    name: wishlist-service
    namespace: default
    spec:
    type: NodePort
    selector:
        app: wishlist
    ports:
    - name: wishlist-port
        protocol: TCP
        port: 8080
    - name: wishlist-auth-port
        protocol: TCP
        port: 8081
    - name: wishlist-catalog-port
        protocol: TCP
        port: 8082

======= REFERENCE 
Project Source code Link : 
https://github.com/bhopals/wishlist

Docker Hub Image Links : 
https://hub.docker.com/r/karthequian/wishlist
https://hub.docker.com/r/karthequian/wishlist-auth
https://hub.docker.com/r/karthequian/wishlist-catalog



======  Alternate Universe! - Microservices deployment 
In the above examle we had Single Deployment and Single Service that contains all 3 part of the application.

Here we would breakup the all three projects into three deployment files. (More of a microservices way)
So its easy to distribute the ownership of the deployments to different teams.


# Wishlist deployment yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: wishlist-app-deployment
    labels:
        app: wishlist-app-deployment
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: wishlist-app-deployment
    template:
        metadata:
        labels:
            app: wishlist-app-deployment
        spec:
        containers:
        - name: wishlist-app-deployment #1st container
            image: karthequian/wishlist:1.0 #Dockerhub image
            ports:
            - containerPort: 8080 #Exposes the port 8080 of the container
            env:
            - name: PORT #Environment variable key passed to container that is read by application
            value: "8080" # Value of the env port.
    ---
    # Wishlist deployment yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: catalog-deployment
    labels:
        app: catalog-deployment
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: catalog-deployment
    template:
        metadata:
        labels:
            app: catalog-deployment
        spec:
        containers:
        - name: catalog #2nd container
            image: karthequian/wishlist-catalog:1.0
            ports:
            - containerPort: 8081
            env:
            - name: PORT
            value: "8081"
    ---
    # Wishlist deployment yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: wishlist-auth-deployment
    labels:
        app: wishlist
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: wishlist-auth-deployment
    template:
        metadata:
        labels:
            app: wishlist-auth-deployment
        spec:
        containers:
        - name: auth #3rd container
            image: karthequian/wishlist-auth:1.0
            ports:
            - containerPort: 8082
            env:
            - name: PORT
            value: "8082"
    ---
    kind: Service
    apiVersion: v1
    metadata:
    name: wishlist-service
    namespace: default
    spec:
    type: NodePort
    selector:
        app: wishlist
    ports:
    - name: wishlist-port
        protocol: TCP
        port: 8080
        targetPort: 8080
    - name: wishlist-auth-port
        protocol: TCP
        port: 8081
        targetPort: 8081
    - name: wishlist-catalog-port
        protocol: TCP
        port: 8082
        targetPort: 8082



==== Adding Context with Config Maps 

# Configmaps

- Config information should live outside the app 
- Implements using ConfigMaps in kubernetes 
- Can be passed as an environment variable ( For the small set of the data )
- Can be used as a volume mount ( For the larger set of the data )

Configuration information should live outside of the application. How can we do this in Kubernetes?

## Goals
1. Create a configmap that can be referenced by the application via env variables
2. Create a configmap that can be referenced by the application via a volume mounted file


## Goal 1
Create the deployment by running 
`kubectl apply -f wishlist-deployment-configmap-simple.yaml`

Exec into the auth container in the wishlist pod with a command like:
`kubectl exec -it wishlist-<podid> -c auth bash`

To look find your env variable run:
`env | grep LOG_LEVEL`

# Configmap (Step 1: Create it)
    kind: ConfigMap
    apiVersion: v1
    metadata:
    name: log-config
    data:
    log-level: debug
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: wishlist-deployment
    labels:
        app: wishlist
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: wishlist
    template:
        metadata:
        labels:
            app: wishlist
        spec:
        volumes:
            - name: config-volume # Configmap (Step 2: Declare as a volume)
            configMap:
                # Provide the name of the ConfigMap containing the files you want
                # to add to the container
                name: log-config
        containers:
        - name: wishlist #1st container
            image: karthequian/wishlist:1.0 #Dockerhub image
            ports:
            - containerPort: 8080 #Exposes the port 8080 of the container
            env:
            - name: PORT #Environment variable key passed to container that is read by application
            value: "8080" # Value of the env port.
            # Define the environment variable
            - name: LOG_LEVEL
            valueFrom:
                configMapKeyRef:
                # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
                name: log-config
                # Specify the key associated with the value
                key: log-level
        - name: catalog #2nd container
            image: karthequian/wishlist-catalog:1.0
            ports:
            - containerPort: 8081
            env:
            - name: PORT
            value: "8081"
            # Define the environment variable
            - name: LOG_LEVEL
            valueFrom:
                configMapKeyRef:
                # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
                name: log-config
                # Specify the key associated with the value
                key: log-level
        - name: auth #3rd container
            image: karthequian/wishlist-auth:1.0
            ports:
            - containerPort: 8082
            env:
            - name: PORT
            value: "8082"
            # Define the environment variable
            - name: LOG_LEVEL
            valueFrom:
                configMapKeyRef:
                # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
                name: log-config
                # Specify the key associated with the value
                key: log-level
    ---
    kind: Service
    apiVersion: v1
    metadata:
    name: wishlist-service
    namespace: default
    spec:
    type: NodePort
    selector:
        app: wishlist
    ports:
    - name: wishlist-port
        protocol: TCP
        port: 8080
        targetPort: 8080
    - name: wishlist-auth-port
        protocol: TCP
        port: 8081
        targetPort: 8081
    - name: wishlist-catalog-port
        protocol: TCP
        port: 8082
        targetPort: 8082




## Goal 2
Create the deployment by running 
`kubectl apply -f wishlist-deployment-configmap-advanced.yaml`

Exec into the auth container in the wishlist pod with a command like:
`kubectl exec -it wishlist-<podid> -c auth bash`

To look find your env variable run:
`cat /var/lib/wishlist/log.properties`


# Configmap (Step 1: Create it)
    apiVersion: v1
    kind: ConfigMap
    metadata:
    name: log-config
    data:
    log.properties: |
        # Root logger option
        log4j.rootLogger=DEBUG, stdout, file
        # Redirect log messages to console
        log4j.appender.stdout=org.apache.log4j.ConsoleAppender
        log4j.appender.stdout.Target=System.out
        log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
        log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
        # Redirect log messages to a log file, support file rolling.
        log4j.appender.file=org.apache.log4j.RollingFileAppender
        log4j.appender.file.File=log4j-application.log
        log4j.appender.file.MaxFileSize=5MB
        log4j.appender.file.MaxBackupIndex=10
        log4j.appender.file.layout=org.apache.log4j.PatternLayout
        log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: wishlist-deployment
    labels:
        app: wishlist
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: wishlist
    template:
        metadata:
        labels:
            app: wishlist
        spec:
        volumes:
            - name: config-volume # Configmap (Step 2: Declare as a volume)
            configMap:
                # Provide the name of the ConfigMap containing the files you want
                # to add to the container
                name: log-config
        containers:
        - name: wishlist #1st container
            image: karthequian/wishlist:1.0 #Dockerhub image
            ports:
            - containerPort: 8080 #Exposes the port 8080 of the container
            env:
            - name: PORT #Environment variable key passed to container that is read by application
            value: "8080" # Value of the env port.
            volumeMounts:
            - name: config-volume
            readOnly: true
            mountPath: "/var/lib/wishlist/"
        - name: catalog #2nd container
            image: karthequian/wishlist-catalog:1.0
            ports:
            - containerPort: 8081
            env:
            - name: PORT
            value: "8081"
            volumeMounts:
            - name: config-volume
            readOnly: true
            mountPath: "/var/lib/wishlist/"
        - name: auth #3rd container
            image: karthequian/wishlist-auth:1.0
            ports:
            - containerPort: 8082
            env:
            - name: PORT
            value: "8082"
            volumeMounts:
            - name: config-volume
            readOnly: true
            mountPath: "/var/lib/wishlist/"
    ---
    kind: Service
    apiVersion: v1
    metadata:
    name: wishlist-service
    namespace: default
    spec:
    type: NodePort
    selector:
        app: wishlist
    ports:
    - name: wishlist-port
        protocol: TCP
        port: 8080
        targetPort: 8080
    - name: wishlist-auth-port
        protocol: TCP
        port: 8081
        targetPort: 8081
    - name: wishlist-catalog-port
        protocol: TCP
        port: 8082
        targetPort: 8082



===NOTE : 
==== kubectl create v/s apply 

These are two very different approaches. 

1.  kubectl create uses Imperative Management. Here You specify what you want to create, delete or replace.

    kubectl apply uses what we call Declarative approach. Here we tell the api How we want the cluster to 
    look like. So even if you've applied changes to a live object, your changes are maintained.

2.  Also, if you run the kubectl create second time, it will throw an error as the deployments and services
    are already created.However, if you run kubectl apply again then it will modify exisiting deployed 
    services and deployments if there is any change in the configuration, else it will remain unchanged 
    and command will be executed without throwing any error.


