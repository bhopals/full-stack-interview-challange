
=== Microservices 
Think of Microservices as a variant of service-oriented architecture that structures the entire
application as a collection of loosely coupled services.

Typically, microservices are broken up with the intent to solve a specific business need or
enable a business capability. 

==== Benefits 
 - freedom to create, manage, and deploy the individual components without compromising the 
   integrity of the entire application.
 - Enables fault tolerance and dfault isolation
 
 - language independence
 - use the right language at the hand 
 - Not pigeonhold to a single language just because the rest of the application uses it.
 - avoid bottleneck of scaling
 - Can be deployed independently
 - Risk of rolling the change back is easy

==== Continuous Delivery Deployment Types 
 Blue Green deployment or Red Black Deployment  - Switch between servers and ensure at least one server is alive at all time 
 A/B Deployment - Routing percentage of traffic on each while deploying   
 Rollback deployment - slowly starting from 1-2 servers instead of going for all simultaneous deployment to ensure the successfully deployment  
 Canary Deployment - release particular feature for certain set of users (Based on region or first name or age range)
 Minimum In-Service deployment - make a policy that minimum numbers of server stay alive while deployment is in progress.
 REFERENCE : https://caylent.com/docker-continuous-delivery-deployment-types/

Building microservices forces you to think about an applications in a more modular way.

For Greenfield opportunities there is a initial learning curve if we use microservice architecture and 
which would pay greater advantage on a long term.

==== The Twelve factor App
Applicable for all cloud and container application

I. Codebase
    One codebase tracked in revision control, many deploys
    GIT,DOCKER

II. Dependencies
    Explicitly declare and isolate dependencies
    MAVEN,NPM,GRADLE
    In kubernetes create a POD that can have all your dependencies. Commonly seen in kubernetes world - SideCar Pattern
III. Config
    Store config in the environment not part of codebase 
   
    Small footprint(small organisations ): Different namespaces with different credentials dev, staging and production
    Large footprint(larger organisations): Unique kubernetes installation for dev, stage, and production

    Applicaton config for kubernetes is ConfigMap and Secrets 
IV. Backing services
    Treat backing services as attached resources
    MYSQL, SMTP EMAIL

V. Build, release, run
    Strictly separate build and run stages
    JENKINS

VI. Processes
    Execute the app as one or more stateless processes
    Sticky session needs to be revisited and re-implemented

VII. Port binding
    Export services via port binding

VIII. Concurrency
    Scale out via the process model

IX. Disposability
    Maximize robustness with fast startup and graceful shutdown
    Quick Application startup and shutdown 

X. Dev/prod parity
    Keep development, staging, and production as similar as possible

XI. Logs
    Treat logs as event streams
    In kubernetes, common to use a log router (Beats/Fluentd) to save the logs to a service (ElasticSearch/Splunk)

XII. Admin processes
    Run admin/management tasks as one-off processes


All 12 Rules are basically categorised in 3 parts.
    - Microservices Building Block 
        - Codebase 
        - Dependencies 
        - Admin Processes
        - Dev/Staging/Production Parity 

    - Deployment Patterns 
        - Application Configurations 
        - Build, release, and run 
        - Processes
        - Port Binding 

    - Runtime Pattersn 
        - Backing around services 
        - Features and Concurrency 
        - Disposability
        - Log Management 
        

==== Microservices Deployment to kubernetes 

===== Deploying our application to Kubernetes

We're ready to deploy our application to Kubernetes, but let's take a look at our assets.

====== Goals:
1. View our sample application and containers
2. Take a look at our deployment file 
3. Take a look at our alternate deployment file
4. Deploy our application into kubernetes and verify we can see our API's working.

======= Goal 1
View the sample application here: 

======= Goal 2
To view the deployment file, take a look at wishlist-deployment.yaml

======= Goal 3
To see another way to run the microservices, take a look at wishlist-deployment-alernate.yaml

======= Goal 4
To run the microservice described in goal #1, from the current directory, run:

`kubectl create -f wishlist-deployment.yaml`

To verify that the deployment is online:
`kubectl get deployments`

To verify that the replica sets are running:
`kubectl get rs`

To verify that the pods are running:
`kubectl get pods`

To see the services:
`kubectl get services`

To interact with your API's in the minikube environment:
`minikube service wishlist-service`


# Wishlist deployment yaml
    kind: Deployment
    apiVersion: apps/v1
    metadata:
    name: wishlist-deployment
    labels:
        app: wishlist
    spec:
    replicas: 3 #We always want more than 1 replica for HA
    selector:
        matchLabels:
        app: wishlist
    template:
        metadata:
        labels:
            app: wishlist
        spec:
        containers:
        - name: wishlist #1st container
            image: karthequian/wishlist:1.0 #Dockerhub image
            ports:
            - containerPort: 8080 #Exposes the port 8080 of the container
            env:
            - name: PORT #Env variable key passed to container that is read by app
            value: "8080" # Value of the env port.
        - name: catalog #2nd container
            image: karthequian/wishlist-catalog:1.0
            ports:
            - containerPort: 8081
            env:
            - name: PORT
            value: "8081"
        - name: auth #3rd container
            image: karthequian/wishlist-auth:1.0
            ports:
            - containerPort: 8082
            env:
            - name: PORT
            value: "8082"
    ---
    kind: Service
    apiVersion: v1
    metadata:
    name: wishlist-service
    namespace: default
    spec:
    type: NodePort
    selector:
        app: wishlist
    ports:
    - name: wishlist-port
        protocol: TCP
        port: 8080
    - name: wishlist-auth-port
        protocol: TCP
        port: 8081
    - name: wishlist-catalog-port
        protocol: TCP
        port: 8082

======= REFERENCE 
Project Source code Link : 
https://github.com/bhopals/wishlist

Docker Hub Image Links : 
https://hub.docker.com/r/karthequian/wishlist
https://hub.docker.com/r/karthequian/wishlist-auth
https://hub.docker.com/r/karthequian/wishlist-catalog



REFERENCE : https://12factor.net/


REFERENCE : https://martinfowler.com/microservices/
