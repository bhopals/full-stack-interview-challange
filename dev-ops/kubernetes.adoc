=== Kubernetes - Desired State Management 

Kubernetes (K8s) is an open-source system for automating deployment, scaling,
and management of containerized applications.

    K8's cluster Services 
    kubnet Workers 

    pod - Smallest unit of deployment - One or multiple running containers / Image details and Replicas information.
    *Can have multiple pods 
    A Kubernetes pod is a group of containers that are deployed together on the same host. If you frequently deploy 
    single containers, you can generally replace the word "pod" with "container" and accurately understand the concept

    Kubernetes Features :

        - Service discovery and load balancing
        - Automatic bin packing
        - Storage orchestration
        - Self-healing
        - Automated rollouts and rollbacks
        - Secret and configuration management
        - Batch Execution
        - Horizentol Scaling


Docker is a platform and tool for building, distributing, and running Docker containers. ... 
Kubernetes is a container orchestration system for Docker containers that is more extensive 
than Docker Swarm and is meant to coordinate clusters of nodes at scale in production in an efficient manner.

===== Create Cluster 

Kubernetes coordinates a highly available cluster of computers that are 
connected to work as a single unit.

A Kubernetes cluster consists of two types of resources:
    -   The Master coordinates the cluster
    -   Nodes are the workers that run applications

Minikube - Minikube is a tool that makes it easy to run Kubernetes locally. 
Minikube runs a single-node Kubernetes cluster inside a Virtual Machine (VM)



    minikube version
    
    minikube start 





==== Pre Requisite 
    - Windows Powershell (For Windows) (Version >=5.1)
    - Enable NotePad for vi commands. 
        new-alias vi notepad 

      The above command will enable Powershell to use notepad editor anytime we run "vi" command.

    

==== Conternazation with Kubernetes -
A container is defined as a collection of software processes unified
by one namespace with access to an operating system kernel that it shares
with other containers and little or no access between them.

=====   Kubernetes -
the most popular open-source container orchestrator available today. 

Container Orchestartion

Orchestration Features:
    - Provision Hosts
    - Instantiate containers on a host 
    - Restart Failing containers 
    - Expose containers as services outside the cluster



DEFINATION - Kubernetes is an open-source platform designed to automate the deployment, scaling, 
and operation of containers.

GOAL - The real goal of the platform is to foster an ecosystem of
components and tools that relieve the burden of running applications in public and private clouds.

Kubernetes, often called K8S or Hubernetes, is an open-source platform that started at Google.

Kubernetes and Docker :
Kubernetes is a container Platform. You can use Docker Containers to develop and build applications and then use
Kubernetes to run these applications on your infrastructure.


===== Kubernetes Features 

    - Multi-Host Container Schedule
        - Done by the kube-scheduler
        - Assigns pods to nodes at runtime
        - Check resources, quality of service, policies, and user specifications before scheduling

    - Scalability and avalability 
        -   5000 nodes clusters 

    - Flixiblity and modularity 
        - Service discovery 

    - Registration and discovery (Service discovery)
    - Persistant Storage 
    - Application Upgrades and maintanence 
    - Logging and Monitering 
    - Secret Management 


    Major Players in Container Orchestartion landscape today are:
        - Kubernetes
        - Docker Swarm 
        - Rancher 
        - Mesos 

    Also, some cloud specific technologies 
        - Amazon EC2 Container 
        - Google cloud 



===== Docker Swarm 
    -   Docker Swarm is responsible for clustering and scheduling containers across hosts. 
    -   It's a simpler architecture when compared to Kubernetes and Mesos. 
    -   It is written in golang and it's a lightweight, declarative language. 
    -   It's easy to get started, setup and understand. 
    -   The typical users of Docker Swarm are smaller teams, like startups and medium-size companies. 
    -   And I've only seen Swarm used in brand new greenfield projects. Which are driven by teams that are mostly
        developers who need to deploy new products. 
     

*Greenfield Projects 
*Brownfield Projects 


===== Mesos 
    -   Mesos on the other hand is written in C++, with APIs in Java, Python, and C++. 
    -   It's the oldest tool of the bunch, but this also means that it's the most stable.
    -   Mesos has a distributed kernel where many machines end up acting like one logical entity. 
    -   The Marathon framework can be added to Mesos to schedule and execute tasks. And finally, 
    -   Mesos has a more complex architecture than Docker Swarm. The typical users of Mesos are 
        larger enterprises that require lots of compute, or jobs/task-oriented workloads. 
    -   Mesos is often used by companies that have to perform big data jobs. I've also seen 
    -   Mesos being driven more by developers rather than operations, but you require an 
        operations team to manage the tool. 
 
 ===== Rancher 
    -   Rancher is a full stack container management platform.
    -   Initially it used to use a custom cluster orchestrator called cattle 
        but now it suppers Kubernetes and Docker Swarm. 
    -   It was an early player in the Docker ecosystem and had orchestration concepts that were way before 
        its time and way before they were a hot topic. It has a great user interface
        and API to interact with clusters and provides enterprise support for its tooling. 
    -   One of the other benefits of Rancher is that it supports organizations and teams out of box. 
        The typical Rancher users are smaller teams, think startups or medium-sized companies. 
        And most of the Rancher users I've seen are developer-driven teams who need to deploy products quickly.
        Or they're dev-ops teams that need to manage an agile infrastructure.
        
        This chart plots the number of hosts and containers versus the size of the development team
  
             ^                              Kubernetes
   Size      |                              Mesos 
    Of       |               Docker Swarm 
    Team     |            Rancher 
             |        Nomad
             ------------------------------------------------------------->
                Numbers of Hosts/Containers 
    




=== Kubernetes Terminology

    ==== Kubernetes architecture

       ===== Master Node :
       Responsible for overall management of Kubernetes Cluster. It has got three componenent that takes care of 
       Communication, Scheduling, and controllers using  Kube API Server, Schedular, Controller Manager.

       Kube API Server - allows you interact with Kubernets API. Front end of kubernete control pane.
      
       Schedular - It watches created PODs who does not have node design yet, and designs the POD to run on a specific node.
        Physically schedules pods based on the criteria provided across all the nodes 
      
       Controller Manager - Runs controllers. The contoller actually has bunch of different roles, and it acts as a single binary.

            - The Node Controller - Workers states
            - The Deployment Controller -
            - The Replication Controller - Maitaining the correct number of pods
            - The End-Point Controller - Which joins Services and Pods together 
            - Service Account and Token Controller - Handles Access Management 

        etcd - Simple Distributed Key Value Store. Acts as DB which stores all cluster data here. 
               Some of the information that might be stored is Job Scheduling info, Pod Details, Stage infromation etc.
                Store current state of the cluster 


        kubectl - A command line interface for kubernetes which allows you to interact with Master Node. kubectl 
                have a config file caled kubeconfig. This file has server information as well as authentication 
                information to access to API Server.


        ===== WORKER NODE :
        Worker Nodes are the nodes where your applications operate. The Worker node communicate back with the Master nodes.
        And this communication is handled by the Kubelet Process.
           
            - kubelete - Its an agent that communicate with API Server, and it is designed to see if 
                                Pods have been designed to the NODES. It executes the POD containers via the container engine.
                                It mounts and runs POD volumes and secrets, and finally it is aware of Pods and Nodes States,
                                and responsd back to the Master.

            - Docker - To run containers on the node we have DOCKER. We could use alternate container platforms as well.

            - kube-proxy - Network Proxy and load balancer for the service on a single worker node. It handles the network
                           routing for TCP and UDP Packets, and performs connection forwarding.
                           A pod is a smallest unit that can be scheduled as a deployment in Kubernetes. This 
                           group of containers share storage, Linux namespace, IP Addresses, amongst other things.
                           
              Once the pod is deployed, the kubelete process communicate with pods to check on health and
              state. And the kube-proxy routes any packets to the PODS from other resources.

              Worker Nodes can be exposed to the internet via load balancer. The traffic coming in would be handled by 
              kube-proxy, and this is how an end-user ends up taking to a Kubernetes Application.





    ===== Basic Building Blocks

        - NODE: The node serves as a worker machine in a K8s cluster. One important thing to note is that 
          the node can be a physical computer or a virtual machine. Node must have following requirements.
            - Node must have A kubelet running 
            - Container tooling like Docker 
            - A kube-proxy process running 
            - Supervisored - so it can restart components.

        ** Recommendation - if you are using Kubernetes in production, it is typically recommended to have at least a three-node cluster.

        ** Minikube - lightweight kubernetes implementation that creates a VM on your local machine and deploys simple 
           cluster containing only one node.

        You applications runs on node. 

        - POD - The Simplest unit that can ineract with you. You can create, deploy and delete pods, and it represent one running process 
                on your cluster.
                Pods is a scheduling unit in Kubernetes.
                A Pod is the basic execution unit of a Kubernetes application
        
        A Kubernetes Pod is a group of one or more Containers, tied together for the purposes of administration 
        and networking.

        Service - An abstract way to expose an application running on a set of Pods as a network service.



        - Whats in the POD 
            - Your docker application container 
            - Storage Resources 
            - Unique Network IP 
            - Options that govern how the container should run. 

        In some scenarios you can have multiple containers running in a Pod, but a pod represents one single unit
        of deployment, a single instance of an application in kubernetes thats tightly coupled and shared resources.

        PODS are ...
         - Empheral, disposable 
         - Never self-heal and not restarted by the scheduler by itself.
         - Never create Pods just by themselves
         - Always use high-level constructs (Use a controller instead for deployments)

        POD States 
         - Pending : Pod has been accepted from kubernetes system, but a container has not been created yet.
         - Running : A Pod has been scheduled on a Node, and all of its containers are created, and at least one 
                     container is in a running state.

         - Succeeded : All the containers in a pod have exited with an exit status of Zero and will not be restarted.

         - Failed : All the containers in the pod have exited and at least one container has failed and return 
                    a non zero exit status.

         - CrashLoopBackOff - This is where containe fails to start for some reason, and kubernetes tries over 
                              and over and over again to restart the pod. 


    ===== Deployments, RaplicaSets, and Services

    - Deployment Controller - It provides declarative updates for PODS and ReplicaSets.
        It internally manages the POD using Replica Sets.

    - Replicasets - Ensures that a specified number of replicas for a pod are running at all times.
    
    - DaemonSets - Ensures that all nodes run a copy of specified pod.
    - Services 


    ===== Labels, Selectors and Namespaces 

    - Labels

    - Selectors :
        - Equality-Based - EQUALS and NOT EQUALS 
        - Set-Based - IN, NOTIN or EXIST Operators (Check value in defined set of values )

    - Namespaces :
    
    

    ===== Kubelet and Kube Proxy

    - Kubelet - The kubelet is the "Kubernets node agent" that runs on each node.

    -Kubelet Roles:
        - Communication with API server to see if pods have been assigned to nodes.
        - Executes pod containers via a container engine 
        - Mounts and runs pod volumnes and secrets
        - Executes health checks to identify pod/node status.

    The kubelet works in terms of Podspec. Podspec is a YAML file describes a POD.
    The kubelet takes a set of Podspecs that are provided by the kube-apiserver and ensures 
    that the containers described in thoes podeSpecs are running and healthy.
    Kubelet only manages containers that are created by the API server - Not any container running on the node.


    - Kube-proxy 
        - Network Proxy is called kube-proxy
        - Process that runs on all worker nodes 
    
    Three Modes of kube-proxy 
        - User space mode - The most common one 
        - Iptables mode 
        - ipvs mode (Alpha feature)

    Why these modes are important

        - These modes are important when it comes to using services.
        - Services are defined against the API Server: kube-proxy watches the SPI Server for the 
          addition and removal of services.
        - For each new services, kube-proxy opens a randomly chosen port on the local node.
        - Connection made to the chosen port are proxied to one of the corresponding back-end pods.



==== Geting Up and Running Kubernetes on Windows 

   1. Install Docker latest version
   2. Insall Hyper V (Its already installed on Windows Machine) 
      We need to make soe configuration changes here.

      We need to create new Virtual Network Switch. For that:
        1. Open "Hyper-v Manager" and Go to Virtual Switch Manager
        2. Select "Internal" 
        3. Click on create Virtual Switch 
        4. Give some name to the switch, for example "Minikube"
        5. Select Internal Network from Radio Button option 
        6. Click on "Ok"

        Thats it. We have created a new virtual switch.

        To Enable the newly created switch 

        1. Go to Control Panel
        2. Search for "Network and Sharing Center"
        3. In the view your active networks Right hand side, you will find Connections "Ethernet"
        4. Click on "Properties" 
        5. Click on "Sharing"
        6. Check the box "Allow other network users to connect through this computers inernet connection"
        7. In the drop down of "Home Networking Connection" select "vEthernet Minikube" (the one we have created in above Section)
        8. Click on "Ok"        

        Virtual Switch - A virtual switch is a software program that allows one virtual machine (VM) to 
        communicate with another. Just like its counterpart, the physical Ethernet switch, a virtual switch
        does more than just forward data packets.

    
    3. Install Kubectl 
        * Download link: https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-via-curl

    4. Install Minikube 
        * General Download Instructions: https://kubernetes.io/docs/tasks/tools/install-minikube/
        * Download link: https://github.com/kubernetes/minikube/releases
   
        Minikube : Minikube is a tool that makes it easy to run Kubernetes locally. 
        Minikube runs a single-node Kubernetes cluster inside a Virtual Machine (VM) on your 
        laptop for users looking to try out Kubernetes or develop with it day-to-day.

    

    5. Once both are downloaded, we need to copy kubectl and minikube executables in a folder and add that folder in 
        Environment Variable 


         docker version
         kubectl version
         minikube version 

     ** Kindly ensure to run all these commands in Windows Power Shell command prompt.


    6. Start the minikube 

        For Windows: 
            minikube start --kubernetes-version="v1.8.0" --vm-driver="hyperv" --hyperv-virtual-switch="Minikube"

        For Mac or Linux:
            minikube start  
            
            minikube clear 

            minikube stop 



    7. Once installation finished, to ensure kubectl is up and running 
        
            kubectl get pods
            kubectl get nodes 
            kubectl get deployments 
            kubectl get rs   (rs - ReplicaSet )

        Also, go to HyperV Manager, you will see "Minikube" in available virtual machines list.


    This is all required to setup kunernetes in Windows machine.


==== Running a First Hello World Application 

    minikube start 

        - It will setup a virtual box for us 

    kubectl get nodes 
       - List of the nodes that are running 


    kubectl run hw --image=karthequian/helloworld --port=80
        - Starts up a deployement 

    kubectl get deployments 
        - List the deployment and its status 

    kubeclt get rs 
        - To get the replica set details (Same as Deployment)

    kubectl get pods 
        - Returns the Pod details 

    kubectl expose deployment hw --type=NodePort 
        - Expose the deployed service 

    kubectl get services 


    minikube service <service-name>
    minikube service hw 
        - It will open the service in browser 

    kubectl get all 
        - It will returns all the details such as  pods, services, deployments, replicaset 
        - In other words, it will return all the resources running on ecosystem.

    kubectl get deploy/hw -o yml 
        - It will returns deployment YML configuration 



    kubectl create -f hello-world-deployment-all.yml 
         - Create service and deployment from YAML configuration 

    To check both service and deployment created 
        kubectl get all 
        OR 
        kubectl get deployment 
        kubectl get service 

    SAMPLE YAML FILE :

    apiVersion: apps/v1beta1
    kind: Deployment
    metadata:
    name: helloworld-all-deployment
    spec:
    selector:
        matchLabels:
        app: helloworld
    replicas: 1 # tells deployment to run 1 pods matching the template
    template: # create pods using pod definition in this template
        metadata:
        labels:
            app: helloworld
        spec:
        containers:
        - name: helloworld
            image: karthequian/helloworld:latest
            ports:
            - containerPort: 80
    ---
    apiVersion: v1
    kind: Service
    metadata:
    name: helloworld-all-service
    spec:
    # if your cluster supports it, uncomment the following to automatically create
    # an external load-balanced IP for the frontend service.
    type: LoadBalancer
    ports:
    - port: 80
        protocol: TCP
        targetPort: 80
    selector:
        app: helloworld



===== Scaling the APP 
  
    kubectl get rs 
        - List all the replica details (Deployments) - Single POD 

    kubectl scale --replicas=3 deploy/helloworld-deployment
        - Here deploy/helloworld-deployment  is the existing deployment 
        - replicas=3 means it will create 3 PODS for the deployment of the application 

    kubectl get deploy/helloworld-deployment 
        - Give the list of the replicas running for that app 

    kubectl get pods 
        - List all the pod details 

    kubectl create -f <yaml-file-name>
        - Create POD

    Sample YML :
        appVersion: v1
        kind: Pod 
        metadata: 
            name:app-pod 
            tier:dev
        spec:
            containers:
                -name:nginx-container
                image:nginx 

    kubectl get pod 
        - List all the pods 

    kubectl get pod -o wide 
        - To show more details (The wide output option passed)

    kubectl get pod nginx-pod -o yaml 
        - Would display the Yaml file details 

    kubectl descrive pod <pod-name>
        - Would list all the details about the pod 

    kubectl exec -it <pod-name> -- /bin/sh 
        - To access the POD using bash 

    kubectl delete pod <pod-name>
        - Delete the pod 


=== Make it Production Ready 


==== Add Lables in POD 

    Sample POD File: 
        
        apiVersion: v1
        kind: Pod
        metadata:
        name: helloworld
        labels:
            env: production
            author: karthequian
            application_type: ui
            release-version: "1.0"
        spec:
        containers:
        - name: helloworld
            image: karthequian/helloworld:latest



    kubectl create -f <yaml.yml>

    kubeclt get pods 
        - List all the pods 

    kubectl get pods --show-labels 
        - List the pod with all the label details 

    kubectl get pods -o wide 
        - Also show the wider details of the pod 

    kubectl label  <pod-name> <new-label-name>=<label-value> --overwrite 

    kubectl label po/helloworld app=helloworldapp --overwrite 
        - Will create/update label of running PODS 


    kubectl label po/helloworld app- 
        - To Delete Label named app 

    kubectl get pods --show-label 
        - List all the labels 
        

===== Working with labels 

instead of "--selector", we could use shortcut "-l" 

kubectl get pods -l env=production
kubectl get pods --selector env=production
    - Filter and show only the label having env set to production     

kubectl get pods -l env!=production
kubectl get pods --selector env!=production
        - Filter and show only the label having env is not production     

kubectl get pods -l env=production, author=bhopal
kubectl get pods --selector env=production, author=bhopal
        - Filter and show only the label having env is production and author is bhopal     

kubectl get pods -l 'release-version in (1.0,1.2)'
kubectl get pods --selector  'release-version in (1.0,1.2)'
        - Filter and show only the label release version in 1.0 or 1.2     

kubectl get pods -l 'release-version notin (1.0,1.2)'
        - Filter and show only the label release version not in 1.0 and 1.2     

kubectl delete pods -l dev-lead=karthik 
    - Delete all the pods with Dev Lead Karthik Label 

    
===== Application Health Check 
We can add below configuration in YAML file to check the readiness and liveness 
readinessProbe:  
     length of time to wait for a pod to initialize
     after pod startup, before applying health checking
livenessProbe:
     length of time to wait for a pod to initialize
     after pod startup, before applying health checking
        

kubectl descrive po/<pod-name>
    - To check for the more details of the POD 


SAMPLE YML with PROBES :

        apiVersion: apps/v1beta1
        kind: Deployment
        metadata:
        name: helloworld-deployment-with-probe
        spec:
        selector:
            matchLabels:
            app: helloworld
        replicas: 1 # tells deployment to run 1 pods matching the template
        template: # create pods using pod definition in this template
            metadata:
            labels:
                app: helloworld
            spec:
            containers:
            - name: helloworld
                image: karthequian/helloworld:latest
                ports:
                - containerPort: 80
                readinessProbe:
                # length of time to wait for a pod to initialize
                # after pod startup, before applying health checking
                initialDelaySeconds: 10
                # Amount of time to wait before timing out
                initialDelaySeconds: 1
                # Probe for http
                httpGet:
                    # Path to probe
                    path: /
                    # Port to probe
                    port: 80
                livenessProbe:
                # length of time to wait for a pod to initialize
                # after pod startup, before applying health checking
                initialDelaySeconds: 10
                # Amount of time to wait before timing out
                timeoutSeconds: 1
                # Probe for http
                httpGet:
                    # Path to probe
                    path: /
                    # Port to probe
                    port: 80

===== Rollback and History of Deployments 

SAMPLE YML :

    apiVersion: apps/v1beta1
    kind: Deployment
    metadata:
    name: navbar-deployment
    spec:
    selector:
        matchLabels:
        app: helloworld
    replicas: 3 # tells deployment to run 3 pods matching the template
    template: # create pods using pod definition in this template
        metadata:
        labels:
            app: helloworld
        spec:
        containers:
        - name: helloworld
            image: karthequian/helloworld:black
            ports:
            - containerPort: 80
    ---
    apiVersion: v1
    kind: Service
    metadata:
    name: navbar-service
    spec:
    # if your cluster supports it, uncomment the following to automatically create
    # an external load-balanced IP for the frontend service.
    type: NodePort
    ports:
    - port: 80
        protocol: TCP
        targetPort: 80
    selector:
        app: helloworld



kubectl create -f <ymlfile.yml>  --record
    - Will start the deployement and service 

kubeclt get deployments 
    - List the deployements 

kubectl set image deployments/<deployment-name> helloworld=<new-image-name>
    - It will automaticall replace the deployed image 

kubectl get rs 
    - List out replica sets 

kubectl rollout history deployment/<name-of-the-deployment> 
    - List out all the history/commands assocaited with this deployment.

kubectl rollout undo deployment/<name-of-the-deployment> 
    - It will rollout/revert latest deplpoyment 

kubectl rollout undo deployment/<name-of-the-deployment> --to-revision=<revision-number>
    - rollout/revert the deployment to specific deployed configuration 


==== REFERENCE
    https://thenewstack.io/kubernetes-vs-docker-swarm-whats-the-difference/
    https://hackernoon.com/kubernetes-vs-docker-swarm-a-comprehensive-comparison-73058543771e


    https://medium.com/@sxia/why-kubernetes-needs-pod-service-and-deployment-f6c96c7d379b
