
== React 

=== 1. REACT INTRO

React is a popular library used to create user interfaces. It was built at Facebook to
address some of the challenges associated with "large-scale", "data-driven" websites.

JSX - Javascript Conversion
SCSS - Need to be Preprocess 
Ecmascript New Syntax - Transpiled - Transpiling - BABEL
Redux - Client Data Container 
React Router - Routing 
Jest - Testing 
Webpack - Handling Code splitting, compression, testing
Isomorphic Code - Server Side Rendering 

Fiber - Reimplementation of React Code Algorithm which is aimed at Increasing rendering speed.


===== REACT DEVELOPER TOOLS
react-detector
show-me-the-react 
React Developer Tools





=== 2. EMERGING JS 

Node.js is JavaScript without the browser. It is a runtime environment used to build
full-stack JavaScript applications.

ECMA - European Computer Manufacturer Association.

FEATURES:
LET  - Lexical Variable Scoping  
TEMPLATE STRING - console.log(${name}, ${age});
DEFAULT PARAMETERS
ARROW FUNCTIONS


ES6 OBJECTS AND ARRAYS 
    - SPREAD OPERATOR - "..." - Combine MULTIPLE ARRAYS into one 
    - DESTRUCTING ASSIGNMENTS - Destructring/unpack Value from the Object or Array 
    - OBJECT LITERAL ENHANCEMENT - Process of restructuring and putting values back in Array or Object (Opposite of DESTRUCTURING)
    
    ```
        // NEW
        const skier = {
            name,
            sound,
            powderYell() {
                let yell = this.sound.toUpperCase()
                console.log(`${yell} ${yell} ${yell}!!!`)
            },
            speed(mph) {
                this.speed = mph
                console.log('speed:', mph)
            }
        }
    ```


BABEL - Transpiling - Transpiled the ES6 Syntax that can be interpreted by wide range of browsers.
You can transpile JavaScript directly in the browser using the inline Babel transpiler.
You just include the browser.js file, and any scripts with type="text/babel" will be
converted.




PROMISES
Promises give us a way to make sense out of asynchronous behavior. When making an
asynchronous request, one of two things can happen: everything goes as we hope or
there’s an error.

CLASSES 

MODULES - Easy Decoupling, resolve namespace ambiguity

ES6 MODULES - A JavaScript module is a piece of reusable code that can easily be incorporated into
other JavaScript files.

COMMONJS - CommonJS is the module pattern that is supported by all versions of Node.js.5.
You can still use these modules with Babel and webpack. With CommonJS, JavaScript
objects are exported using module.exports.

The Difference Between ES6 Modules & COMMON JS is that the Common JS does not support IMPORT, it uses "require".
Also while exporting it uses "module.exports={fun1, func2}, compared to ES6 Modules which uses "export / export default infront of methods".
More Info: https://medium.com/computed-comparisons/commonjs-vs-amd-vs-requirejs-vs-es6-modules-2e814b114a0b




=== 3. Functional Programming with JavaScript

Functional Programming came from LAMDA CALCULUS


HIGH ORDER FUNCTIONS - A higher order function is a function that takes a function as an argument, or returns a function.
The first category of higher-order functions are functions that expect other functions
as arguments. Array.map, Array.filter, and Array.reduce all take functions as
arguments. They are higher-order functions.

const userLogs = userName => message =>
console.log(`${userName} -> ${message}`)

Transpiled version of the ABOVE:

"use strict";
var userLogs = function userLogs(a) {
  return function (b) {
    return console.log(a + " -> " + b);
  };
};



const compose = (...fns) =>
(arg) =>
fns.reduce(
(composed, f) => f(composed),
arg
)

Transpiled version of the ABOVE:

"use strict";
var compose = function compose() {
  for (var a = arguments.length, b = Array(a), c = 0; c < a; c++) b[c] = arguments[c];

  return function (d) {
    return b.reduce(function (e, g) {
      return g(e);
    }, d);
  };
};



FIRST-CLASS CITIZENS/MEMBERS - We can say that JavaScript is a functional language because its functions are first-class
citizens. This means that functions are data. They can be saved, retrieved, or flow
through your applications just like variables.


DECLARATIVE PROGRAMMING - Declarative programming is a style of programming where applications
are structured in a way that prioritizes describing what should happen over defining
how it should happen.

IMPERATIVE PROGRAMMING - Imperative programming, or a style of programming that is only concerned with how to achieve
results with code.


FUNCTIONAL CONCEPTS:
    
    Immutability - 
        Object.assign({}, object)
        Using spread "..." operator 

    Purity -
            PURE FUNCTIONS  : A pure function is a function that returns a value that is computed based on its arguments.
            Pure functions take at least one argument and always return a value or
            another function. They do not cause side effects, set global variables, or change anything
            about application state. They treat their arguments as immutable data.

                1. The function should take in at least one argument.
                2. The function should return a value or another function.
                3. The function should not change or mutate any of its arguments.


    Data Transformation
            Array.map
            Array.reduce
            Array.join
            Array.filter 
            Array.reduce 
            Array.reduceRight
            Array.reduceLeft
            Array.slice 
            Array.splice 
            Array.pop
            Array.push 



    Higher-Order Functions 
    Recursion




=== 4. PURE REACT 

    React - React is the Library to create Views  
    ReactDOM - ReactDOM is the library to actually Renders the views in the DOM/Browser 

    Initially both libraries were part of one package, but later on both were splitted to pave a way to share the packages between ReactDom and React Native.


    data-reactroot - which identifies that this is the root element of your React component
                     data-reactroot will always appear as an attribute of the root element of your React component.   


    React element is just a JavaScript literal that tells React how to construct the DOM element

    Sample React Element:
    {
        $$typeof: Symbol(React.element),
        "type": "h1",
        "key": null,
        "ref": null,
        "props": {"children": "Baked Salmon"},
        "_owner": null,
        "_store": {}
    }


    ReactDOM 
        -render()
        -renderToString()
        -renderToStaticMarkup


    React Components:


     -  Stateless functional components are functions that take in properties and return a
        DOM element. Stateless functional components are functions, not objects; therefore, they do not
        have a “this” scope


    React has built-in factories for all commonly supported HTML and SVG DOM elements,
    and you can use the React.createFactory function to build your own factories
    around specific components.

    ```
    React.DOM.ul({"className": "ingredients"},
        React.DOM.li(null, "1 lb Salmon"),
        React.DOM.li(null, "1 cup Pine Nuts"),
        React.DOM.li(null, "2 cups Butter Lettuce"),
        React.DOM.li(null, "1 Yellow Squash"),
        React.DOM.li(null, "1/2 cup Olive Oil"),
        React.DOM.li(null, "3 cloves of Garlic")
    )
    ```


===== Babel Presets
    
        Babel 6 breaks possible transformations up into modules called presets. It requires
        engineers to explicitly define which transformations should be run by specifying
        which presets to use. The goal was to make everything more modular to allow developers
        to decide which syntax should be converted. The plugins fall into a few categories,
        and all are opt-in based on the needs of the application. The presets you’re
        most likely to use are:
    
        babel-preset-es2015
        Compiles ES2015, or ES6, to ES5.
    
        babel-preset-es2016
        Compiles what is in ES2016 to ES2015


        babel-preset-env
        Compiles everything from ES2015, ES2016, ES2017. A catch-all for the previous
        three presets

    ====== WebPack 

        Webpack is billed as a module bundler (static module bundler). A module bundler takes all of our different
        files (JavaScript, LESS, CSS, JSX, ES6, and so on) and turns them into a single file.
        The two main benefits of modular bundling are modularity and network performance.

        Modularuty - 
            Modularity will allow you to break down your source code into parts, or modules,
            that are easier to work with, especially in a team environment.
        
        Network performance -
            Network performance is gained by only needing to load one dependency in the
            browser, the bundle. Each script tag makes an HTTP request, and there is a latency
            penalty for each HTTP request. Bundling all of the dependencies into a single file
            allows you to load everything with one HTTP request, thereby avoiding additional
            latency.


        Aside from transpiling, webpack also can handle:

            Code splitting -
                Splits up your code into different chunks that can be loaded when you need
                them. Sometimes these are called rollups or layers; the aim is to break up code as
                needed for different pages or devices.

            Minification -
                Removes whitespace, line breaks, lengthy variable names, and unnecessary code
                to reduce the file size.

            Feature flagging -
                Sends code to one or more—but not all—environments when testing out features.
            
            Hot Module Replacement (HMR) - 
                Watches for changes in source code. Changes only the updated modules immediately.


            ** WebPack Loaders are the functions that handles Transpiling.





=== REFERENCE :

    BOOK NAME : Learning Reacts - Alex Banks and Leo Procello
    REFERENCE : - https://github.com/moonhighway/learning-react