
== React 

=== 1. REACT INTRO

React is a popular library used to create user interfaces. It was built at Facebook to
address some of the challenges associated with "large-scale", "data-driven" websites.

JSX - Javascript Conversion
SCSS - Need to be Preprocess 
Ecmascript New Syntax - Transpiled - Transpiling - BABEL
Redux - Client Data Container 
React Router - Routing 
Jest - Testing 
Webpack - Handling Code splitting, compression, testing
Isomorphic Code - Server Side Rendering 

Fiber - Reimplementation of React Code Algorithm which is aimed at Increasing rendering speed.


===== REACT DEVELOPER TOOLS
react-detector
show-me-the-react 
React Developer Tools





=== 2. EMERGING JS 

Node.js is JavaScript without the browser. It is a runtime environment used to build
full-stack JavaScript applications.

ECMA - European Computer Manufacturer Association.

FEATURES:
LET  - Lexical Variable Scoping  
TEMPLATE STRING - console.log(${name}, ${age});
DEFAULT PARAMETERS
ARROW FUNCTIONS


ES6 OBJECTS AND ARRAYS 
    - SPREAD OPERATOR - "..." - Combine MULTIPLE ARRAYS into one 
    - DESTRUCTING ASSIGNMENTS - Destructring/unpack Value from the Object or Array 
    - OBJECT LITERAL ENHANCEMENT - Process of restructuring and putting values back in Array or Object (Opposite of DESTRUCTURING)
    
    ```
        // NEW
        const skier = {
            name,
            sound,
            powderYell() {
                let yell = this.sound.toUpperCase()
                console.log(`${yell} ${yell} ${yell}!!!`)
            },
            speed(mph) {
                this.speed = mph
                console.log('speed:', mph)
            }
        }
    ```


BABEL - Transpiling - Transpiled the ES6 Syntax that can be interpreted by wide range of browsers.
You can transpile JavaScript directly in the browser using the inline Babel transpiler.
You just include the browser.js file, and any scripts with type="text/babel" will be
converted.




PROMISES
Promises give us a way to make sense out of asynchronous behavior. When making an
asynchronous request, one of two things can happen: everything goes as we hope or
there’s an error.

CLASSES 

MODULES - Easy Decoupling, resolve namespace ambiguity

ES6 MODULES - A JavaScript module is a piece of reusable code that can easily be incorporated into
other JavaScript files.

COMMONJS - CommonJS is the module pattern that is supported by all versions of Node.js.5.
You can still use these modules with Babel and webpack. With CommonJS, JavaScript
objects are exported using module.exports.

The Difference Between ES6 Modules & COMMON JS is that the Common JS does not support IMPORT, it uses "require".
Also while exporting it uses "module.exports={fun1, func2}, compared to ES6 Modules which uses "export / export default infront of methods".
More Info: https://medium.com/computed-comparisons/commonjs-vs-amd-vs-requirejs-vs-es6-modules-2e814b114a0b




=== 3. Functional Programming with JavaScript

Functional Programming came from LAMDA CALCULUS


HIGH ORDER FUNCTIONS - A higher order function is a function that takes a function as an argument, or returns a function.
The first category of higher-order functions are functions that expect other functions
as arguments. Array.map, Array.filter, and Array.reduce all take functions as
arguments. They are higher-order functions.

const userLogs = userName => message =>
console.log(`${userName} -> ${message}`)

Transpiled version of the ABOVE:

"use strict";
var userLogs = function userLogs(a) {
  return function (b) {
    return console.log(a + " -> " + b);
  };
};



const compose = (...fns) =>
(arg) =>
fns.reduce(
(composed, f) => f(composed),
arg
)

Transpiled version of the ABOVE:

"use strict";
var compose = function compose() {
  for (var a = arguments.length, b = Array(a), c = 0; c < a; c++) b[c] = arguments[c];

  return function (d) {
    return b.reduce(function (e, g) {
      return g(e);
    }, d);
  };
};



FIRST-CLASS CITIZENS/MEMBERS - We can say that JavaScript is a functional language because its functions are first-class
citizens. This means that functions are data. They can be saved, retrieved, or flow
through your applications just like variables.


DECLARATIVE PROGRAMMING - Declarative programming is a style of programming where applications
are structured in a way that prioritizes describing what should happen over defining
how it should happen.

IMPERATIVE PROGRAMMING - Imperative programming, or a style of programming that is only concerned with how to achieve
results with code.


FUNCTIONAL CONCEPTS:
    
    Immutability - 
        Object.assign({}, object)
        Using spread "..." operator 

    Purity -
            PURE FUNCTIONS  : A pure function is a function that returns a value that is computed based on its arguments.
            Pure functions take at least one argument and always return a value or
            another function. They do not cause side effects, set global variables, or change anything
            about application state. They treat their arguments as immutable data.

                1. The function should take in at least one argument.
                2. The function should return a value or another function.
                3. The function should not change or mutate any of its arguments.


    Data Transformation
            Array.map
            Array.reduce
            Array.join
            Array.filter 
            Array.reduce 
            Array.reduceRight
            Array.reduceLeft
            Array.slice 
            Array.splice 
            Array.pop
            Array.push 



    Higher-Order Functions 
    Recursion




=== 4. PURE REACT 

    React - React is the Library to create Views  
    ReactDOM - ReactDOM is the library to actually Renders the views in the DOM/Browser 

    Initially both libraries were part of one package, but later on both were splitted to pave a way to share the packages between ReactDom and React Native.


    data-reactroot - which identifies that this is the root element of your React component
                     data-reactroot will always appear as an attribute of the root element of your React component.   


    React element is just a JavaScript literal that tells React how to construct the DOM element

    Sample React Element:
    {
        $$typeof: Symbol(React.element),
        "type": "h1",
        "key": null,
        "ref": null,
        "props": {"children": "Baked Salmon"},
        "_owner": null,
        "_store": {}
    }


    ReactDOM 
        -render()
        -renderToString()
        -renderToStaticMarkup


    React Components:


     -  Stateless functional components are functions that take in properties and return a
        DOM element. Stateless functional components are functions, not objects; therefore, they do not
        have a “this” scope


    React has built-in factories for all commonly supported HTML and SVG DOM elements,
    and you can use the React.createFactory function to build your own factories
    around specific components.

    ```
    React.DOM.ul({"className": "ingredients"},
        React.DOM.li(null, "1 lb Salmon"),
        React.DOM.li(null, "1 cup Pine Nuts"),
        React.DOM.li(null, "2 cups Butter Lettuce"),
        React.DOM.li(null, "1 Yellow Squash"),
        React.DOM.li(null, "1/2 cup Olive Oil"),
        React.DOM.li(null, "3 cloves of Garlic")
    )
    ```


===== Babel Presets
    
        Babel 6 breaks possible transformations up into modules called presets. It requires
        engineers to explicitly define which transformations should be run by specifying
        which presets to use. The goal was to make everything more modular to allow developers
        to decide which syntax should be converted. The plugins fall into a few categories,
        and all are opt-in based on the needs of the application. The presets you’re
        most likely to use are:
    
        babel-preset-es2015
        Compiles ES2015, or ES6, to ES5.
    
        babel-preset-es2016
        Compiles what is in ES2016 to ES2015


        babel-preset-env
        Compiles everything from ES2015, ES2016, ES2017. A catch-all for the previous
        three presets

    ====== WebPack 

        Webpack is billed as a module bundler (static module bundler). A module bundler takes all of our different
        files (JavaScript, LESS, CSS, JSX, ES6, and so on) and turns them into a single file.
        The two main benefits of modular bundling are modularity and network performance.

        Modularuty - 
            Modularity will allow you to break down your source code into parts, or modules,
            that are easier to work with, especially in a team environment.
        
        Network performance -
            Network performance is gained by only needing to load one dependency in the
            browser, the bundle. Each script tag makes an HTTP request, and there is a latency
            penalty for each HTTP request. Bundling all of the dependencies into a single file
            allows you to load everything with one HTTP request, thereby avoiding additional
            latency.


        Aside from transpiling, webpack also can handle:

            Code splitting -
                Splits up your code into different chunks that can be loaded when you need
                them. Sometimes these are called rollups or layers; the aim is to break up code as
                needed for different pages or devices.

            Minification -
                Removes whitespace, line breaks, lengthy variable names, and unnecessary code
                to reduce the file size.

            Feature flagging -
                Sends code to one or more—but not all—environments when testing out features.
            
            Hot Module Replacement (HMR) - 
                Watches for changes in source code. Changes only the updated modules immediately.


            ** WebPack Loaders are the functions that handles Transpiling.

            Source mapping
                Bundling our code into a single file can cause some setbacks when it comes time to
                debug the application in the browser. We can eliminate this problem by providing a
                source map


            Webpack Sample File:

            ```
                var webpack = require("webpack");
                module.exports = {
                    entry: "./src/index.js",
                    output: {
                        path: "dist/assets",
                        filename: "bundle.js",
                        sourceMapFilename: 'bundle.map'
                    },
                    devtool: '#source-map',
                    module: {
                        rules: [
                            {
                                test: /\.js$/,
                                exclude: /(node_modules)/,
                                loader: ['babel-loader'],
                                query: {
                                    presets: ['env', 'stage-0', 'react']
                                }
                            }
                        ]
                    },
                    plugins: [
                        new webpack.optimize.UglifyJsPlugin({
                            sourceMap: true,
                            warnings: false,
                            mangle: true
                        })
                    ]
                }
            
            ```


=== Props, State, and the Component Tree


    ==== Property Validation:
            Type        Validator
            ---------   ---------------------
            Arrays      React.PropTypes.array
            Boolean     React.PropTypes.bool
            Functions   React.PropTypes.func
            Numbers     React.PropTypes.number
            Objects     React.PropTypes.object
            Strings     React.PropTypes.string

        ```
        Prop Type Check only :

        propTypes: {
            ingredients: PropTypes.array,
            steps: PropTypes.array,
            title: PropTypes.string
        },


        Prop Type and Required Check :

        propTypes: {
            ingredients: PropTypes.array.isRequired,
            steps: PropTypes.array.isRequired,
            title: PropTypes.string.isRequired
        },

        ```

    ==== Default Props 
         
         ```
         getDefaultProps() {
            return {
                ingredients: 0,
                steps: 0,
                title: "[recipe]"
            }
        },

        ```
        Now when we try to render this component without properties, we will see some
        default data instead
    


    ==== Custom Property Validation

        Custom validation in React is implemented with a function. This function should
        either return an error when a specific validation requirement is not met or null when
        the property is valid.


        ```
        propTypes: {
            ingredients: PropTypes.number,
            steps: PropTypes.number,
            title: (props, propName) =>
                (typeof props[propName] !== 'string') ?
                    new Error("A title must be a string") :
                (props[propName].length > 20) ?
                    new Error(`title is over 20 characters`) : null
        }
        ```

        *** This will be in RENER Method. However, in ES6 Sytax (give below), it would be outside the class.

        ===== PropTypes Check / Default Props and Custom Validations for ES6 Classes 
        
        ```
            class Summary extends React.Component {
                render() {
                    const {ingredients, steps, title} = this.props
                    return (
                    <div className="summary">
                    <h1>{title}</h1>
                    <p>
                    <span>{ingredients} Ingredients | </span>
                    <span>{steps} Steps</span>
                    </p>
                    </div>
                    )
                }
            }
           
            Summary.propTypes = {
                ingredients: PropTypes.number,
                steps: PropTypes.number,
                title: (props, propName) =>
                (typeof props[propName] !== 'string') ?
                new Error("A title must be a string") :
                (props[propName].length > 20) ?
                new Error(`title is over 20 characters`) : null 
            }

            Summary.defaultProps = {
                ingredients: 0,
                steps: 0,
                title: "[recipe]"
            }

            ```

            OR For Stateless Functional Component 

            ```
            const Summary = ({ ingredients, steps, title }) => {
                return <div>
                <h1>{title}</h1>
                <p>{ingredients} Ingredients | {steps} Steps</p>
                </div>
            }
            
            Summary.propTypes = {
                ingredients: React.PropTypes.number.isRequired,
                steps: React.PropTypes.number.isRequired
            }
            
            Summary.defaultProps = {
                ingredients: 1,
                steps: 1
            }

            ```


        ===== Class Static Properties 

            In the previous section, we looked at how defaultProps and propTypes are defined
            outside of the class. An alternative to this is emerging in one of the latest proposals to
            the ECMAScript spec: Class Fields & Static Properties.

            ```
                class Summary extends React.Component {
                    static propTypes = {
                        ingredients: PropTypes.number,
                        steps: PropTypes.number,
                        title: (props, propName) =>
                        (typeof props[propName] !== 'string') ?
                        new Error("A title must be a string") :
                        (props[propName].length > 20) ?
                        new Error(`title is over 20 characters`) :
                        null
                    }
                
                    static defaultProps = {
                        ingredients: 0,
                        steps: 0,
                        title: "[recipe]"
                    }
                
                    render() {
                        const {ingredients, steps, title} = this.props
                        return (
                        <div className="summary">
                        <h1>{title}</h1>
                        <p>
                        <span>{ingredients} Ingredients | </span>
                        <span>{steps} Steps</span>
                        </p>
                        </div>
                        )
                    }
                }

            ```




     ==== Refs 

        References, or refs, are a feature that allow React components to interact with child
        elements. The most common use case for refs is to interact with UI elements that collect
        input from the user.

        ```
            import { Component } from 'react'
            
            class AddColorForm extends Component {
            
                constructor(props) {
                    super(props)
                    this.submit = this.submit.bind(this)
                }
            
                submit(e) {
                    const { _title, _color } = this.refs
                    e.preventDefault();
                    alert(`New Color: ${_title.value} ${_color.value}`)
                    _title.value = '';
                    _color.value = '#000000';
                    _title.focus();
                }
            
                render() {
                    return (
                        <form onSubmit={this.submit}>
                        <input ref="_title"
                        type="text"
                        placeholder="color title..." required/>
                        <input ref="_color"
                        type="color" required/>
                        <button>ADD</button>
                        </form>
                    )
                }
            }
        

        ```        

        Define Default Dummy function in props if function is undefined :

        AddColorForm.propTypes = {
            onNewColor: PropTypes.func
        }
        AddColorForm.defaultProps = {
            onNewColor: f=>f
        }



        Refs can also be used in stateless functional components. These components do not
        have this, so it’s not possible to use this.refs. Instead of using string attributes, we
        will set the refs using a function.
        ** Let’s refactor AddColorForm as a stateless functional component:

           ```
            const AddColorForm = ({onNewColor=f=>f}) => {
                let _title, _color
                const submit = e => {
                    e.preventDefault()
                    onNewColor(_title.value, _color.value)
                    _title.value = ''
                    _color.value = '#000000'
                    _title.focus()
                }

                return (
                    <form onSubmit={submit}>
                    <input ref={input => _title = input}
                    type="text"
                    placeholder="color title..." required/>
                    <input ref={input => _color = input}
                    type="color" required/>
                    <button>ADD</button>
                    </form>
                )
            }


        ```



     ===== React State Management 

     State - State represents data that we may wish to change within a component.

        ```
        const Star = ({ selected=false, onClick=f=>f }) =>
            <div className={(selected) ? "star selected" : "star"}
            onClick={onClick}>
            </div>
        
        Star.propTypes = {
            selected: PropTypes.bool,
            onClick: PropTypes.func
        }

        ```


        ===== State Within the React Component 
        In many React applications, it is possible to group all state data in the root component.
        State data can be passed down the component tree via properties, and data can
        be passed back up the tree to the root via two-way function binding. 
        
        The result is that all of the state for your entire application exists in one place. This is often referred to
        as having a “single source of truth.”4

        Presentational components are only concerned with how things look in the application. 
        
        They only render DOM elements or other presentational components. All data is sent to these components via properties and passed
        out of these components via callback functions.


        A library to create Unique ID's 
        ** npm install uuid --save
        import { v4 } from 'uuid'






 === Enhancing Components


    ==== Component Life Cycle 

        There are two primary lifecycles: the mounting lifecycle and the updating lifecycle.

        ===== Mounting Life Cycles   -  The mounting lifecycle consists of methods that are invoked when a component is
                                        mounted or unmounted


            Table - The component mounting lifecycle
        
            ES6 class                   React.createClass()
            -----------------------     ------------------------   
            getDefaultProps()           -
            constructor(props)          getInitialState()
            componentWillMount()        componentWillMount()
            render()                    render()           
            componentDidMount()         componentDidMount()
            componentWillUnmount()      componentWillUnmount()


        ===== Updating Life Cycles 

            The updating lifecycle kicks off every time setState is called. Calling setState
            within the updating lifecycle will cause an infinite recursive loop that results in a
            stack overflow error. Therefore, setState can only be called in componentWillRecei
            veProps, which allows the component to update state when its properties are updated.


            The updating lifecycle methods include:
                
                1. componentWillReceiveProps(nextProps) -
                    Only invoked if new properties have been passed to the component. This is the
                    only method where setState can be called.
            
                2. shouldComponentUpdate(nextProps, nextState)
                    The update lifecycle’s gatekeeper—a predicate that can call off the update. This
                    method can be used to improve performance by only allowing necessary updates.
                    componentWillUpdate(nextProps, nextState)
                    Invoked just before the component updates. Similar to componentWillMount,
                    only it is invoked before each update occurs.
            
                3. componentDidUpdate(prevProps, prevState)
                    Invoked just after the update takes place, after the call to render. Similar to compo
                    nentDidMount, but it is invoked after each update.


            ** componentWillMount will be deprecated after react 17.0, so instead, we can use componentDidMount

            ```
                componentWillMount() {
                    this.style = { backgroundColor: "#CCC" }
                }

                shouldComponentUpdate(nextProps) {
                    return this.props.rating !== nextProps.rating
                }

                componentWillUpdate(nextProps) {
                    const { title, rating } = this.props
                    this.style = null
                    this.refs.title.style.backgroundColor = "red"
                    this.refs.title.style.color = "white"
                    alert(`${title}: rating ${rating} -> ${nextProps.rating}`)
                }

                componentDidUpdate(prevProps) {
                    const { title, rating } = this.props
                    const status = (rating > prevProps.rating) ? 'better' : 'worse'
                    this.refs.title.style.backgroundColor = ""
                    this.refs.title.style.color = "black"
                }

            ```


        ===== React.Children

            React.Children provides a way of working with the children of a particular component.
            It allows you to count, map, loopover, or convert props.children to an array. It
            also allows you to verify that you are displaying a single child with
            React.Children.only:
        
                import { Children, PropTypes } from 'react'
                import { render } from 'react-dom'
        
                const Display = ({ ifTruthy=true, children }) =>
                    (ifTruthy) ?
                    Children.only(children) :
                    null
                    const age = 22
        
                render(
                        <Display ifTruthy={age >= 21}>
                        <h1>You can enter</h1>
                        </Display>,
                        document.getElementById('react-container')
                )
    
            We can also use React.Children to convert the children property to an array.



            ===== Making Requests with Fetch
            Fetch is a polyfill created by the WHATWG group that allows us to easily make API
            calls using promises. In this section we will introduce isomorphic-fetch, a version of
            Fetch that works nicely with React. Let’s install isomorphic-fetch:

            npm install isomorphic-fetch --save
            
            ```

            componentDidMount() {
                this.setState({loading: true})
                fetch('https://restcountries.eu/rest/v1/all')
                .then(response => response.json())
                .then(json => json.map(country => country.name))
                .then(countryNames =>
                this.setState({countryNames, loading: false})
                )
            }

            ```

            **WHATWG - Web Hypertext Application Technologies Working Group.


        
        ==== High Order Functions 

            A higher-order component, or HOC, is a simply a function that takes a React component
            as an argument and returns another React component. Typically, HOCs wrap
            the incoming component with a class that maintains state or has functionality.
            Higher-order components are the best way to reuse functionality across React components.

            ```
            const DataComponent = (ComposedComponent, url) =>
            class DataComponent extends Component {
                constructor(props) {
                    super(props)
                    this.state = {
                        data: [],
                        loading: false,
                        loaded: false
                    }
                }

                componentWillMount() {
                    this.setState({loading:true})
                    fetch(url)
                    .then(response => response.json())
                    .then(data => this.setState({
                    loaded: true,
                    loading: false,
                    data
                    }))
                }

                render() {
                    return (
                    <div className="data-component">
                    {(this.state.loading) ?
                    <div>Loading...</div> :
                    <ComposedComponent {...this.state} />}
                    </div>
                    )
                }
            }

            ```

        
        ==== Flux 
            Flux is a design pattern developed at Facebook that was designed to keep data flowing
            in one direction. Before Flux was introduced, web development architecture was
            dominated by variations of the MVC design pattern. Flux is an alternative to MVC,
            an entirely different design pattern that complements the functional approach.

            In Flux, application state data is managed outside of React components in stores.
            Stores hold and change the data, and are the only thing that can update a view in
            Flux. If a user were to interact with a web page—say, click a button or submit a form
            — then an action would be created to represent the user’s request. An action provides
            the instructions and data required to make a change. Actions are dispatched using a
            central control component called the dispatcher. The dispatcher is designed to queue
            up our actions and dispatch them to the appropriate store. Once a store receives an
            action, it will use it as instructions to modify state and update the view. Data flows in
            one direction: action to a dispatcher to the store and finally to the view


                        
            ACTION --> DISPATCHER ---> STORE ---> VIEW 
                           ^
                           |
                           |
                         ACTION

            Actions and state data are immutable in Flux. Actions can be dispatched from a view,
            or they can come from other sources, typically a web server.
            Every change requires an action. Every action provides the instructions to make the
            change.

            ===== Actions and Action Creators
                Actions provide the instructions and data that the store will use to modify the state.
                Action creators are functions that can be used to abstract away the nitty-gritty details
                required to build an action. Actions themselves are objects that at minimum contain
                a type field. The action type is typically an uppercase string that describes the action.
                Additionally, actions may package any data required by the store. For example:
                
                ```
                const countdownActions = dispatcher =>
                ({
                    tick(currentCount) {
                    dispatcher.handleAction({ type: 'TICK' })
                },
                    reset(count) {
                        dispatcher.handleAction({
                            type: 'RESET',
                            count
                        })
                    }
                })

                ```

                ===== Dispatcher

                    There is only ever one dispatcher, and it represents the air traffic control part of this
                    design pattern. The dispatcher takes the action, packages it with some information about where the action was generated, and sends it on to the appropriate store or
                    stores that will handle the action.
                    Although Flux is not a framework, Facebook does open source a Dispatcher class
                    that you can use. How dispatchers are implemented is typically standard, so it is better
                    to use Facebook’s dispatcher rather than coding your own
                    
                    ```
                    import Dispatcher from 'flux'
                    class CountdownDispatcher extends Dispatcher {
                        handleAction(action) {
                            console.log('dispatching action:', action)
                            this.dispatch({
                                source: 'VIEW_ACTION',
                                action
                            })
                        }
                    }
                    
                    ```


                    ===== Stores
                    Stores are objects that hold the application’s logic and state data. Stores are similar to
                    models in the MVC pattern, but stores are not restricted to managing data in a single
                    object. It is possible to build Flux applications that consist of a single store that manages
                    many different data types

                    Current state data can be obtained from a store via properties. Everything a store
                    needs to change state data is provided in the action. A store will handle actions by
                    type and change their data accordingly. Once data is changed, the store will emit an
                    event and notify any views that have subscribed to the store that their data has
                    changed. Let’s take a look at an example:
                   
                    import { EventEmitter } from 'events'
                    class CountdownStore extends EventEmitter {
                        constructor(count=5, dispatcher) {
                        super()
                        this._count = count
                        this.dispatcherIndex = dispatcher.register(
                            this.dispatch.bind(this)
                        )
                    }

                    get count() {
                        return this._count
                    }
                    
                    dispatch(payload) {
                        const { type, count } = payload.action
                        switch(type) {
                            case "TICK":
                            this._count = this._count - 1
                            this.emit("TICK", this._count)
                            return true
                            case "RESET":
                            this._count = count
                            this.emit("RESET", this._count)
                            return true
                        }
                    }
                }

                This store holds the countdown application’s state, the count. The count can be
                accessed through a read-only property. When actions are dispatched, the store uses
                them to change the count. A TICK action decrements the count. A RESET action
                resets the count entirely with data that is included with the action.
                Once the state has changed, the store emits an event to any views that may be listening.


                Putting It All Together
                ------------------------------
                Now that you understand how data flows through each part of a Flux application, let’s
                take a look at how all these parts get connected:

                const appDispatcher = new CountdownDispatcher()
                const actions = countdownActions(appDispatcher)
                const store = new CountdownStore(10, appDispatcher)
                const render = count => ReactDOM.render(
                
                <Countdown count={count} {...actions} />,
                    document.getElementById('react-container')
                )

                store.on("TICK", () => render(store.count))
                store.on("RESET", () => render(store.count))
                render(store.count)



            ===== Flux Implementations
            There are different approaches to the implementation of Flux. A few libraries have
            been open-sourced based upon specific implementations of this design pattern. Here
            are a few approaches to Flux worth mentioning:
            
             - Flux :
                    Facebook’s Flux is the design pattern that we just covered. The Flux library
                    includes an implementation of a dispatcher.

             - Reflux :
                    A simplified approach to unidirectional data flow that focuses on actions, stores,
                    and views.

             - Flummox :
                A Flux implementation that allows you to build Flux modules through extending
                JavaScript classes.

             - Fluxible :
                A Flux framework created by Yahoo for working with isomorphic Flux applications.
                Isomorphic applications will be discussed in Chapter 12.
             
             - Redux
                A Flux-like library that achieves modularity through functions instead of objects.
                MobX
            
            A state management library that uses observables to respond to changes in state.
            All of these implementations have stores, actions, and a dispatch mechanism, and
            favor React components as the view layer. They are all variations of the Flux design
            pattern, which at its core is all about unidirectional data flow.
            


            === Redux 
            Redux is a predictable state container for JavaScript apps.
            Redux is based on Flux Design Pattern, and it was designed to tackle the challenge of understanding
            how data changes flow through your application.

            Redux also introduces reducers, which are
            not a part of the Flux pattern. Reducers are pure functions that return a new state
            based on the current state and an action: (state, action) => newState.


            ACTION
            ACTION PAYLOAD 
            REDUCER - 
                Reducers are functions that take the current state along with an action as arguments
                and use them to create and return a new state.
                We can then compose reducers into one reducer that can handle updating the entire state of our app given any action.     

                Redux has a function for
                doing just that, combineReducers, which combines all of the reducers into a single
                reducer. These reducers are used to build your state tree. The names of the fields
                match the names of the reducers that are passed in.

                ```
                export const sort = (state = "SORTED_BY_DATE", action) => {
                    switch (action.type) {
                        case C.SORT_COLORS:
                        return action.sortBy
                        default :
                        return state
                    }
                }
                
                ```

            STORE -
                In Redux, the store is what holds the application’s state data and handles all state
                updates. While the Flux design pattern allows for many stores that each focus on a
                specific set of data, Redux only has one store.

                ```
                    import { createStore, combineReducers } from 'redux'
                    import { colors, sort } from './reducers'

                    const initialState = {
                        colors: [
                            {
                                id: "3315e1p5-3abl-0p523-30e4-8001l8yf3036",
                                title: "Rad Red",
                                color: "#FF0000",
                                rating: 3,
                                timestamp: "Sat Mar 12 2016 16:12:09 GMT-0800 (PST)"
                            },
                            {
                                id: "3315e1p5-3abl-0p523-30e4-8001l8yf4457",
                                title: "Crazy Green",
                                color: "#00FF00",
                                rating: 0,
                                timestamp: "Fri Mar 11 2016 12:00:00 GMT-0800 (PST)"
                            },
                            {
                                id: "3315e1p5-3abl-0p523-30e4-8001l8yf2412",
                                title: "Big Blue",
                                color: "#0000FF",
                                rating: 5,
                                timestamp: "Thu Mar 10 2016 01:11:12 GMT-0800 (PST)"
                            }
                        ],
                        sort: "SORTED_BY_TITLE"
                    }

                    const store = createStore(
                        combineReducers({ colors, sort }),
                        initialState
                    )

                ```

                STORE DISPATCHIN ACTIONS :
                    ```
                    store.dispatch({
                            type: "ADD_COLOR",
                            id: "2222e1p5-3abl-0p523-30e4-8001l8yf2222",
                            title: "Party Pink",
                            color: "#F142FF",
                            timestamp: "Thu Mar 10 2016 01:11:12 GMT-0800 (PST)"
                    })

                    ```

                SUBSCRIBE TO STORE - Stores allow you to subscribe handler functions that are invoked every time the store
                completes dispatching an action. In the following example, we will log the count of
                colors in the state:

                ```
                
                    store.subscribe(() =>
                        console.log('color count:', store.getState().colors.length)
                    )

                    store.dispatch({
                        type: "ADD_COLOR",
                        id: "2222e1p5-3abl-0p523-30e4-8001l8yf2222",
                        title: "Party Pink",
                        color: "#F142FF",
                        timestamp: "Thu Mar 10 2016 01:11:12 GMT-0800 (PST)"
                    })

                    store.dispatch({
                        type: "ADD_COLOR",
                        id: "3315e1p5-3abl-0p523-30e4-8001l8yf2412",
                        title: "Big Blue",
                        color: "#0000FF",
                        timestamp: "Thu Mar 10 2016 01:11:12 GMT-0800 (PST)"
                    })

                    store.dispatch({
                        type: "RATE_COLOR",
                        id: "2222e1p5-3abl-0p523-30e4-8001l8yf2222",
                        rating: 5
                    })

                    store.dispatch({
                        type: "REMOVE_COLOR",
                        id: "3315e1p5-3abl-0p523-30e4-8001l8yf2412"
                    })

                ```


                UNSUBSCRIBE TO STORE - 
                    The store’s subscribe method returns a function that you can use later to unsubscribe
                    the listener:

                    const logState = () => console.log('next state', store.getState())
                    
                    const unsubscribeLogger = store.subscribe(logState)
                    // Invoke when ready to unsubscribe the listener
                    unsubscribeLogger()


                SAVING TO LOCAL STORAGE - 
                    Using the store’s subscribe function, we will listen for state changes and save those
                    changes to localStorage under the key 'redux-store'. When we create the store we
                    can check to see if any data has been saved under this key and, if so, load that data as
                    our initial state. With just a few lines of code, we can have persistent state data in the
                    browser:

                    ```
                    const store = createStore(
                        combineReducers({ colors, sort }),
                        (localStorage['redux-store']) ?
                        JSON.parse(localStorage['redux-store']) :
                        {}
                    )
                    
                    store.subscribe(() => {
                        localStorage['redux-store'] = JSON.stringify(store.getState())
                    })

                    console.log('current color count', store.getState().colors.length)
                    console.log('current state', store.getState())
                    
                    store.dispatch({
                        type: "ADD_COLOR",
                        id: uuid.v4(),
                        title: "Party Pink",
                        color: "#F142FF",
                        timestamp: new Date().toString()
                    })

                    ```

                    ACTION CREATOR - 
                        We can simplify the logic involved with generating an action by adding an action creators
                        for each of these action types:

                        import C from './constants'

                        export const removeColor = id =>
                        ({
                            type: C.REMOVE_COLOR,
                            id
                        })

                        export const rateColor = (id, rating) =>
                        ({
                            type: C.RATE_COLOR,
                            id,
                            rating
                        })

                        //DISPATCHING ACTIONS USING ACTION CREATOR 
                        store.dispatch( removeColor("3315e1p5-3abl-0p523-30e4-8001l8yf2412") )
                        store.dispatch( rateColor("441e0p2-9ab4-0p523-30e4-8001l8yf2412", 5) )

                    The really nice thing about action creators is that they provide a place to encapsulate
                    all of the logic required to successfully create an action

                    Action creators are where we should put any logic for communicating with backend
                    APIs. With an action creator, we can perform asynchronous logic like requesting data
                    or making an API call. 


                    ===== Middleware 
                        Redux also has middleware. It acts on the store’s dispatch pipeline. In Redux, middleware
                        consists of a series of functions that are executed in a row in the process of dispatching
                        an action.
                        In Redux, middleware is
                        defined as a higher-order function: it’s a function that returns a function that returns
                        a function. The last function returned is invoked every time an action is dispatched.
                        When this function is invoked, you have access to the


            === REACT-REDUX


=== REFERENCE :

    BOOK NAME : Learning Reacts - Alex Banks and Leo Procello
    REFERENCE : - https://github.com/moonhighway/learning-react
