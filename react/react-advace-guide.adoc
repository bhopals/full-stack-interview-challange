
== React Advance Concepts 

=== Accesibility
    -   aria-label
    -   focus
    -   title tag


=== Code Splitting


    1.  Splitting main bundle into multiple bundles and load them as required by using Code-Splitting Feature of WebPack.
    2.  Code-splitting your app can help you lazy load the code bundles as required. To achieve that 



====  Using dynamic import: Import specific files in the project 

            BEFORE :
            import { add } from './math';
            console.log(add(16, 26));

            AFTER:
            import("./math").then(math => {
                console.log(math.add(16, 26));
            }); 

==== Using React.lazy

The React.lazy function lets you render a dynamic import as a regular component.

        BEFORE:
        import OtherComponent from './OtherComponent';

        function MyComponent() {
        return (
                <div>
                <OtherComponent />
                </div>
            );
        }

        AFTER:
        const OtherComponent = React.lazy(() => import('./OtherComponent'));

        function MyComponent() {
        return (
                <div>
                <OtherComponent />
                </div>
            );
        }

This will automatically load the bundle containing the OtherComponent when this component gets rendered.

React.lazy takes a function that must call a dynamic import(). This must return a Promise which resolves to a module with a default export containing a React component.


====  Suspense 
If the module containing the OtherComponent is not yet loaded by the time MyComponent renders, 
we must show some fallback content while we’re waiting for it to load - such as a loading indicator. 
This is done using the Suspense component.

        const OtherComponent = React.lazy(() => import('./OtherComponent'));

        function MyComponent() {
        return (
                <div>
                    <Suspense fallback={<div>Loading...</div>}>
                        <OtherComponent />
                    </Suspense>
                </div>
            );
        }



====    Error boundaries  
If the other module fails to load (for example, due to network failure), 
it will trigger an error. You can handle these errors to show a nice user experience and manage
recovery with Error Boundaries. Once you’ve created your Error Boundary, you can use it anywhere 
above your lazy components to display an error state when there’s a network error.


            import MyErrorBoundary from './MyErrorBoundary';
            const OtherComponent = React.lazy(() => import('./OtherComponent'));
            const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

            const MyComponent = () => (
            <div>
                <MyErrorBoundary>
                <Suspense fallback={<div>Loading...</div>}>
                    <section>
                    <OtherComponent />
                    <AnotherComponent />
                    </section>
                </Suspense>
                </MyErrorBoundary>
            </div>
            );

            ** A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). 


====   Route-based code splitting


    import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
    import React, { Suspense, lazy } from 'react';

    const Home = lazy(() => import('./routes/Home'));
    const About = lazy(() => import('./routes/About'));


====    Named Exports 
React.lazy currently only supports default exports. If the module you want to import uses 
named exports, you can create an intermediate module that reexports it as the default. This ensures that
tree shaking keeps working and that you don’t pull in unused components.

        // ManyComponents.js
        export const MyComponent = /* ... */;
        export const MyUnusedComponent = /* ... */;

        // MyComponent.js
        export { MyComponent as default } from "./ManyComponents.js";
        
        // MyApp.js
        import React, { lazy } from 'react';
        const MyComponent = lazy(() => import("./MyComponent.js"));





=== Context
Context provides a way to pass data through the component tree without having to pass props down 
manually at every level.

Context is designed to share data that can be considered “global” for a tree of React components, such as the current 
authenticated user, theme, or preferred language.

====    React.createContext

    const MyContext = React.createContext(defaultValue);  //To Set the default Value 

Creates a Context object. When React renders a component that subscribes to this Context object 
it will read the current context value from the closest matching Provider above it in the tree.


====    Context.Provider
    
    <MyContext.Provider value={/* some value */}>

Every Context object comes with a Provider React component that allows consuming components 
to subscribe to context changes.

====    Class.contextType

    class MyClass extends React.Component {
        componentDidMount() {
            let value = this.context;
            /* perform a side-effect at mount using the value of MyContext */
        }
        componentDidUpdate() {
            let value = this.context;
            /* ... */
        }
        componentWillUnmount() {
            let value = this.context;
            /* ... */
        }
        render() {
            let value = this.context;
            /* render something based on the value of MyContext */
        }
    }

    MyClass.contextType = MyContext;


The contextType property on a class can be assigned a Context object created by React.createContext(). 
This lets you consume the nearest current value of that Context type using this.context. You can reference
 this in any of the lifecycle methods including the render function.

 ====   Context.Consumer

    <MyContext.Consumer>
        {value => /* render something based on the context value */}
    </MyContext.Consumer>

A React component that subscribes to context changes. This lets you subscribe to a context 
within a function component.

REFERENCE : https://reactjs.org/docs/context.html
