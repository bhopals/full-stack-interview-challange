== Spring 
Spring Framework is a Java platform that provides comprehensive infrastructure support for 
developing Java applications. Spring handles the infrastructure so you can focus on your application.


** Spring is unopinionated, 
** Spring Boot takes an opinionated view of the platform and libraries, letting us get started quickly

==== What is Spring 
Simply put, the Spring framework provides comprehensive infrastructure support for developing 
Java applications.

It’s packed with some nice features like Dependency Injection and out of the box modules like:

- Spring JDBC
- Spring MVC
- Spring Security
- Spring AOP
- Spring ORM
- Spring Test


==== Spring Framework
It supports declarative transaction management, remote access to your logic through RMI or 
web services, and various options for persisting your data. It offers a full-featured MVC 
framework, and enables you to integrate AOP transparently into your software.

Spring is designed to be non-intrusive, meaning that your domain logic code generally has no
dependencies on the framework itself. In your integration layer (such as the data access layer), some
dependencies on the data access technology and the Spring libraries will exist. However, 
it should be easy to isolate these dependencies from the rest of your code base.

===== Modules
The Spring Framework consists of features organized into about 20 modules. These modules are grouped
into Core Container, Data Access/Integration, Web, AOP (Aspect Oriented Programming),
Instrumentation, and Test.


===== Dependency injection (DI) -> Inversion of Control (IoC) -> Service Locator Pattern

===== Constructor-based or setter-based DI ?
Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use
constructors for mandatory dependencies and setter methods or configuration methods for
optional dependencies.

The Spring team generally advocates constructor injection, as it lets you implement
application components as immutable objects and ensures that required dependencies are
not null.

Setter injection should primarily only be used for optional dependencies that can be assigned
reasonable default values within the class. 

==== Scope 
- Singelton  : default - One per ApplicationContext
- Prototype
- Request
- Session
- Application - One per ServletContext
- Websocket 


* Application Scope is somewhat similar to a
Spring singleton bean but differs in two important ways: It is a singleton per ServletContext, not per
Spring 'ApplicationContext' (for which there may be several in any given web application), and it is
actually exposed and therefore visible as a ServletContext attribute.

* Bean Scope per Ioc Container.
* As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans.


==== Bean Life Cycle 
A bean life cycle includes the following steps. 

1. Within IoC container, a spring bean is created using class constructor. 

2. Now the dependency injection is performed using setter method. 

3. Once the dependency injection is completed, BeanNameAware.setBeanName() is called. It sets the 
    name of bean in the bean factory that created this bean. 

4. Now < code>BeanClassLoaderAware.setBeanClassLoader() is called that supplies the bean class 
    loader to a bean instance. 

5. Now < code>BeanFactoryAware.setBeanFactory() is called that provides the owning factory to a 
    bean instance. 

6. Now the IoC container calls BeanPostProcessor.postProcessBeforeInitialization on the bean. 
    Using this method a wrapper can be applied on original bean. 

7. Now the method annotated with @PostConstruct is called. 

8. After @PostConstruct, the method InitializingBean.afterPropertiesSet() is called. 

9. Now the method specified by init-method attribute of bean in XML configuration is called. 

10. And then BeanPostProcessor.postProcessAfterInitialization() is called. It can also be used to
    apply wrapper on original bean. 

11. Now the bean instance is ready to be used. Perform the task using the bean. 

12. Now when the ApplicationContext shuts down such as by using registerShutdownHook() then 
    the method annotated with @PreDestroy is called. 

13. After that DisposableBean.destroy() method is called on the bean. 

14. Now the method specified by destroy-method attribute of bean in XML configuration is called. 

15. Before garbage collection, finalize() method of Object is called.

Spring Bean Life Cycle – Bean Initialization and Destruction
June 21, 2016 by javainterviewpoint Leave a Comment


Spring IoC container is also responsible for managing the Spring Bean Life Cycle, 
the life cycle of beans consist of call back methods such as Post initialization call back 
method and Pre destruction call back method. Below steps are followed by Spring IoC Container 
to manage bean life cycle.

Spring Bean Life Cycle
Creation of bean instance by a factory method.
Set the values and bean references to the bean properties.
Call the initialization call back method.
Bean is ready for use.
Call the destruction call back method.

==== Bean init/destroy 

Spring can recognize the initialization and destruction callback methods in the below three ways.

1. A Bean can implement the InitializingBean and DisposableBean life cycle interfaces and 
    overriding the afterPropertiesSet() (Called during Spring bean initialization) and destroy() 
    methods for initialization and destruction respectively.

2. Set the init-method and destroy-method attributes in the bean configuration file.

3. Use @PostConstruct and @PreDestroy over the methods (Spring 2.5 or later) which is defined in JSR-250.

Bean Initialization lifecycle callback methods are called on all objects regardless of scope, in the
case of prototypes, configured destruction lifecycle callbacks are not called. 
The client code must clean up prototype-scoped objects and release expensive
resources that the prototype bean(s) are holding.


==== Spring Core 
https://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/core.pdf#spring-core


===== 1.3.2. Instantiating Beans
Instantiation with a Constructor
Instantiation with a Static Factory Method
Instantiation by Using an Instance Factory Method


===== 1.4.1. Dependency Injection
Constructor-based Dependency Injection
Setter-based Dependency Injection

===== 1.4.4. Lazy-initialized Beans
By default, ApplicationContext implementations eagerly create and configure all singleton 
beans as part of the initialization process. 

    <bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>

OR

    <beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
    </beans>

It will by default lazy initialize all the beans.

===== 1.6. Customizing the Nature of a Bean

• Lifecycle Callbacks
   -  Implement InitializingBean and DisposableBean interfaces and call afterPropertiesSet() for the
        former and destroy() for later

   -  @PostConstruct and @PreDestroy 

   -  Using init-method and destroy-method bean definition metadata

• ApplicationContextAware and BeanNameAware
• Other Aware Interfaces



===== As of Spring 2.5, you have three options for controlling bean lifecycle behavior:
• The InitializingBean and DisposableBean callback interfaces
• Custom init() and destroy() methods
• The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control
    a given bean.


===== Difference between <context:annotation-config> vs <context:component-scan>

<context:annotation-config> is used to activate annotations in beans already registered in the 
application context (no matter if they were defined with XML or by package scanning).
Autowiring of beans 



<context:component-scan> can also do what <context:annotation-config> does but 
<context:component-scan> also scans packages to find and register beans within the application context.
Autowiring of beans + Autodiscovery of beans

==== REFERENCE 
https://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/
