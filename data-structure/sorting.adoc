

== Sorting Algorithms 

- Stable and Unstable Sort 
- Bubble Sort 

=== Stable v/s Unstable Sort.

If two identical values in the array retain the relative position while sorting then it is Stable sort, otherwise it is 
unstable Sort.

Unsorted ARRAY - [8, 3, 1, 3, 2, 9]
Sorted ARRAY -   [1, 2, 3, 3, 8, 9]

So here in example after sorting, is Both "3" has maitain the order. Means the first "3" is still coming before second "3".
If the relative ordering of duplicate item has been preserver then its Stable sort otherwise Unstable Sort.  

=== Bubble Sort 

Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping 
the adjacent elements if they are in wrong order.


** Bubble Sort is Stable Sort 

*An example of Quadratic Algorithm

Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.

Best Case Time Complexity: O(n). Best case occurs when array is already sorted.

Auxiliary Space: O(1)

Boundary Cases: Bubble sort takes minimum time (Order of n) when elements are already sorted.

Sorting In Place: Yes

Stable: Yes

Due to its simplicity, bubble sort is often used to introduce the concept of a sorting algorithm.
The performance degrades as the size increases. For 10 Items, it takes 100 Steps to sort, for 100 items it takes 10000 steps to sort the array.

Its in-place algorithms as it does not require any extra memory space to sort the elements.


==== Practical Use of Bubble Sort
Its a type of sorting, best used when the data is small. i.e. the list of elements to be sorted is low.

==== Example  

    import java.util.HashSet;
    import java.util.Set;

    public class Main {

        // Driver program
        public static void main(String[] args) {

            int array[] = { 55, 3, 50, 23, 65, -12, -3, 5 };

            for (int unsortedArrayIndex = array.length - 1; unsortedArrayIndex > 0; unsortedArrayIndex--) {

                for (int i = 0; i < unsortedArrayIndex; i++) {

                    if (array[i] > array[i + 1]) {
                        swap(array, i , i+1);
                    }
                }
            }
            
            for(int i = 0; i < array.length; i++){
                System.out.println(array[i]+" ");
            }
        }

        private static void swap(int array[], int currentIndex, int targetIndex) {
            
            if(currentIndex == targetIndex) {
                return;
            }
            
            int temp = array[currentIndex];
            array[currentIndex] = array[targetIndex];
            array[targetIndex] = temp;
                
        }

    }





=== Selection Sort 

Always pick the 0th index and make it largest and then iterate till the end to match if any other largest element present.
If so then make set the largest to that value.




Once the iteration is over swap the largest value with the last item of the unsorted array.

The selection sort algorithm sorts an array by repeatedly finding
the minimum element (considering ascending order) from unsorted part 
and putting it at the beginning.

In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.


- Less swaping then bubble sort. As we saw the swapping was performed only at the end of each iteration.
- Unstable Algorithm 

Time Complexity: O(n2) as there are two nested loops.

Auxiliary Space: O(1)
The good thing about selection sort is it never makes more than O(n) swaps and can be useful when memory write is a costly operation.


Stability : The default implementation is not stable. However it can be made stable.

In Place : Yes, it does not require extra space.

==== Example 

        package com.algoritms.sorting;

        import java.util.Arrays;

        public class SelectionSort {

            public static void main(String[] args) {
                
                int array[] = {9, 5, 34, 1, 76, 5, 12}; 
            
                for(int unsortedIndex=array.length-1; unsortedIndex > 0 ; unsortedIndex--) {
                    int largest = 0;
                    for(int i=0;i<=unsortedIndex;i++) {
                        if(array[largest] < array[i]) {
                            largest = i;
                        }
                    }
                    swap(array, unsortedIndex, largest);
                    
                    System.out.println("AFTER:"+Arrays.toString(array));
                }
                
                System.out.println();
                for (int i = 0; i < array.length; i++) {
                    System.out.print(array[i]+" ");
                }
            }
            
            private static void swap(int array[], int usi , int largest) {
                
                if(usi==largest) {
                    return;
                }
                
                int temp = array[usi];
                array[usi] = array[largest];
                array[largest] = temp;		
            }
        }




=== Insertion Sort 


==== Usecase 

When to use:
    
    Only a few items
    Items are mostly sorted already



==== Example 

    package com.algoritms.sorting;

    import java.util.Arrays;

    public class InsertionSort {

        public static void main(String[] args) {

            int array[] = {34, 3, 4, 12,1,67, 5};
            
            for(int unsortedIndex=1; unsortedIndex<array.length; unsortedIndex++) {
                
                int i;
                
                int element = array[unsortedIndex];
                
                for(i=unsortedIndex; i > 0 && array[i-1] > element; i--) {
                    array[i] = array[i-1];
                }
                array[i] = element;
            }
            
            System.out.println(Arrays.toString(array));
        }

    }



==== Between insertion sort and selection sort, when to use which?



Usually, insertion sort will perform less comparisons than selection sort, 
depending on the degree of "sortedness" of the array. While selection sort must 
scan the remaining parts of the array when placing an element, insertion sort only 
scans as many elements as necessary. That means that when the array is already sorted or 
almost sorted, insertion sort performs in O(n) time.

One advantage of selection sort over insertion sort, is that the number of writes (swaps) 
is in O(n), while in insertion sort it is in O(n^2). This may be important if you are sorting 
on Flash memory, for example, because writes reduce the lifespan of Flash memory.

=== REFERENCE

If we talk about Arrays.sort(int[] a) method in java Arrays (Java Platform SE 8 ), 
it doesnâ€™t use bubble sort at all. Depends on the array length, it uses merge sort, quick sort, insertion sort 
and count sort. From the source code there are different threshold defined for the sorting algorithm to 
be used. 
For example if array length is greater than 286 merge sort, 
less than 286 but greater than 47 quick sort, less than 47 insertion sort is used.