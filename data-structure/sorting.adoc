

== Sorting Algorithms 

- Stable and Unstable Sort 
- Bubble Sort 

=== Stable v/s Unstable Sort.

If two identical values in the array retain the relative position while sorting then it is Stable sort, otherwise it is 
unstable Sort.

Unsorted ARRAY - [8, 3, 1, 3, 2, 9]
Sorted ARRAY -   [1, 2, 3, 3, 8, 9]

So here in example after sorting, is Both "3" has maitain the order. Means the first "3" is still coming before second "3".
If the relative ordering of duplicate item has been preserver then its Stable sort otherwise Unstable Sort.  

=== Bubble Sort 

Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping 
the adjacent elements if they are in wrong order.


** Bubble Sort is Stable Sort 

*An example of Quadratic Algorithm

Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.

Best Case Time Complexity: O(n). Best case occurs when array is already sorted.

Auxiliary Space: O(1)

Boundary Cases: Bubble sort takes minimum time (Order of n) when elements are already sorted.

Sorting In Place: Yes

Stable: Yes

Due to its simplicity, bubble sort is often used to introduce the concept of a sorting algorithm.
The performance degrades as the size increases. For 10 Items, it takes 100 Steps to sort, for 100 items it takes 10000 steps to sort the array.

Its in-place algorithms as it does not require any extra memory space to sort the elements.


==== Practical Use of Bubble Sort
Its a type of sorting, best used when the data is small. i.e. the list of elements to be sorted is low.

==== Example  

    import java.util.HashSet;
    import java.util.Set;

    public class Main {

        // Driver program
        public static void main(String[] args) {

            int array[] = { 55, 3, 50, 23, 65, -12, -3, 5 };

            for (int unsortedArrayIndex = array.length - 1; unsortedArrayIndex > 0; unsortedArrayIndex--) {

                for (int i = 0; i < unsortedArrayIndex; i++) {

                    if (array[i] > array[i + 1]) {
                        swap(array, i , i+1);
                    }
                }
            }
            
            for(int i = 0; i < array.length; i++){
                System.out.println(array[i]+" ");
            }
        }

        private static void swap(int array[], int currentIndex, int targetIndex) {
            
            if(currentIndex == targetIndex) {
                return;
            }
            
            int temp = array[currentIndex];
            array[currentIndex] = array[targetIndex];
            array[targetIndex] = temp;
                
        }

    }





=== Selection Sort 

Always pick the 0th index and make it largest and then iterate till the end to match if any other largest element present.
If so then make set the largest to that value.




Once the iteration is over swap the largest value with the last item of the unsorted array.

The selection sort algorithm sorts an array by repeatedly finding
the minimum element (considering ascending order) from unsorted part 
and putting it at the beginning.

In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.


- Less swaping then bubble sort. As we saw the swapping was performed only at the end of each iteration.
- Unstable Algorithm 

Time Complexity: O(n2) as there are two nested loops.

Auxiliary Space: O(1)
The good thing about selection sort is it never makes more than O(n) swaps and can be useful when memory write is a costly operation.


Stability : The default implementation is not stable. However it can be made stable.

In Place : Yes, it does not require extra space.

==== Example 

        package com.algoritms.sorting;

        import java.util.Arrays;

        public class SelectionSort {

            public static void main(String[] args) {
                
                int array[] = {9, 5, 34, 1, 76, 5, 12}; 
            
                for(int unsortedIndex=array.length-1; unsortedIndex > 0 ; unsortedIndex--) {
                    int largest = 0;
                    for(int i=0;i<=unsortedIndex;i++) {
                        if(array[largest] < array[i]) {
                            largest = i;
                        }
                    }
                    swap(array, unsortedIndex, largest);
                    
                    System.out.println("AFTER:"+Arrays.toString(array));
                }
                
                System.out.println();
                for (int i = 0; i < array.length; i++) {
                    System.out.print(array[i]+" ");
                }
            }
            
            private static void swap(int array[], int usi , int largest) {
                
                if(usi==largest) {
                    return;
                }
                
                int temp = array[usi];
                array[usi] = array[largest];
                array[largest] = temp;		
            }
        }




=== Insertion Sort 
Insertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands.

Start from index = 1, and pick up elements and match with already sorted array (The front one).
If its less then swap with one position till you either hit start of the array or you find large element exists.

/ Sort an arr[] of size n
insertionSort(arr, n)
Loop from i = 1 to n-1.
……a) Pick element arr[i] and insert it into sorted sequence arr[0…i-1]

==== Usecase 

When to use:
    
    Only a few items
    Items are mostly sorted already



Time Complexity: O(n*2)

Auxiliary Space: O(1)

Boundary Cases: Insertion sort takes maximum time to sort if elements are sorted in reverse order.
 And it takes minimum time (Order of n) when elements are already sorted.

Algorithmic Paradigm: Incremental Approach

Sorting In Place: Yes

Stable: Yes

Online: Yes

Uses: Insertion sort is used when number of elements is small. It can also be useful when input array is 
almost sorted, only few elements are misplaced in complete big array.

What is Binary Insertion Sort?
We can use binary search to reduce the number of comparisons in normal insertion sort. Binary Insertion
 Sort uses binary search to find the proper location to insert the selected item at each iteration.
  In normal insertion, sorting takes O(i) (at ith iteration) in worst case. We can reduce it to O(logi) 
  by using binary search. The algorithm, as a whole, still has a running worst case running time of O(n2)
   because of the series of swaps required for each insertion. Refer this for implementation.

==== Example 

    package com.algoritms.sorting;

    import java.util.Arrays;

    public class InsertionSort {

        public static void main(String[] args) {

            int array[] = {34, 3, 4, 12,1,67, 5};
            
            for(int unsortedIndex=1; unsortedIndex<array.length; unsortedIndex++) {
                
                int i;
                
                int element = array[unsortedIndex];
                
                for(i=unsortedIndex; i > 0 && array[i-1] > element; i--) {
                    array[i] = array[i-1];
                }
                array[i] = element;
            }
            
            System.out.println(Arrays.toString(array));
        }

    }



==== Between insertion sort and selection sort, when to use which?



Usually, insertion sort will perform less comparisons than selection sort, 
depending on the degree of "sortedness" of the array. While selection sort must 
scan the remaining parts of the array when placing an element, insertion sort only 
scans as many elements as necessary. That means that when the array is already sorted or 
almost sorted, insertion sort performs in O(n) time.

One advantage of selection sort over insertion sort, is that the number of writes (swaps) 
is in O(n), while in insertion sort it is in O(n^2). This may be important if you are sorting 
on Flash memory, for example, because writes reduce the lifespan of Flash memory.


=== Shell Sort 

    - Variation of Insertion Sort 
    - Insertion Sort chooses which element to insert using gap 1
    - Shell sort starts out using a larger gap value 
    - As the algorithm runs, the gap reduced 
    - Goal is to reduce the amount of shifting required 
    - As the algorithms progressess the gap is reduced 
    - The last gap value is alwayus 1
    - So, the algorithm does some preliminary work (using gap value greater than 1), and then becomes insertion sort 
    - By the time we get to insertion sort, the array has been partially sorted, so there is les shifting required



=== Recursion



==== Example 

        package com.algoritms.sorting;
        public class Recursive {
            public static void main(String[] args) {
                System.out.println(recursion(3));
                System.out.println(iterativeRecursion(3));
            }
            
            private static int recursion(int number) {
                int fact = 1;
                if (number == 0) {
                    return fact;
                }
                return fact *= number * recursion(number-1);
            }
            
            private static int iterativeRecursion(int number) {
                int fact = 1;
                if(number == 0) {
                    return fact;
                }
                for(int i=1;i<=number;i++){
                    fact*=i;
                }
                return fact;
            }
        }



=== Merge Sort 

 - It works on Recursion 
 - Divide and Conquer algorithm 
 - Recursive Algorithm 
 - Two phases: Splitting and Merging 
 - Splitting phase leads to faster sorting during the Merging phase 
 - Splitting is logical. We don't create new arrays 


Splitting and Merging Phase Details:

 Merge Sort - Splitting Phase 
 
 - Start with an unsorted array 
 - Divide the array into two arrays, which are unsorted.
   The first array is the left array, and the second array is the right array.
 - Split the left and right arrays into two arrays each 
 - Keep splitting until all the arrays have only one element eacgh - These arrays are sorted.

 Merge Sort - Merging Phase 
 - Merge every left/right pair of sibling arrays into a sorted array 
 - After the first merge, we will have a bunch of 2-elements sorted arrays.
 - Then merge those sorted arrays (left/right siblings) to end up with a bunch of 4-element sorted arrays.
 - Repeat until you have a single sorted array
 - Not in-place - Uses Temporary arrays.  


Merge Sort 
 - Not in-place algorithm 
 - Stable Algorithm 
 - O(nlogn) base 2 




=== Quick Sort 
  - Divide and conquer algorithm
  - Recursive Algorithm 
  - Uses a pivot element to partition the array into two parts
  - Element < pivot to its left, element > pivot to its right 
  - Pivot will then be in its correct sorted position 

  - Once the above process is completed, the process is now repeated for the left array and right array.
  - Eventually, every element has been the pivot, so every element will be in its corrected sorted position. 
  - As with merge sort, we will end up partitioning the array into a series of 1-element arrays.
  - Does this in-place (unlike merge sort which requires temp memory to stror temp array values)

  - Pivot will be the first element in the array (or subarray)

    

=== REFERENCE

-   First of all, one should ask why use a quadratic sorting algorithm when asymptotically faster alternatives 
    exists, like mergesort or quicksort. For small arrays (less than 20-30 elements), both insertion sort and 
    selection sort are typically faster than the O(n*logn) alternatives. In fact, many sorting algorithms based 
    on the divide and conquer paradigm switch to insertion sort or selection sort when the array is small enough.


-   If we talk about Arrays.sort(int[] a) method in java Arrays (Java Platform SE 8 ), 
    it doesn’t use bubble sort at all. Depends on the array length, it uses merge sort, quick sort, insertion sort 
    and count sort. From the source code there are different threshold defined for the sorting algorithm to 
    be used. 
    For example if array length is greater than 286 merge sort, 
    less than 286 but greater than 47 quick sort, less than 47 insertion sort is used.